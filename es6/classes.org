* Overview
A class and a subclass:

#+BEGIN_SRC js :results values list :exports both
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return `(${this.x}, ${this.y})`;
    }
}

class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y);
        this.color = color;
    }
    toString() {
        return super.toString() + ' in ' + this.color;
    }
}

#+END_SRC

Using the classes:

#+BEGIN_SRC js :results values list :exports both
> const cp = new ColorPoint(25, 8, 'green');
> cp.toString();
'(25, 8) in green'
> cp instanceof ColorPoint
true
> cp instanceof Point
true

#+END_SRC

Under the hood, ES6 classes are not something that is radically new: They mainly provide more convenient syntax to create old-school constructor functions. You can see that if you use typeof:


#+BEGIN_SRC js :results values list :exports both
> typeof Point
'function'
#+END_SRC

* The essentials
** Base classes
A class is defined like this in ECMAScript 6:

#+BEGIN_SRC js :results values list :exports both
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return `(${this.x}, ${this.y})`;
    }
}
#+END_SRC

You use this class just like an ES5 constructor function:

#+BEGIN_SRC js :results values list :exports both
> var p = new Point(25, 8);
> p.toString()
'(25, 8)'
#+END_SRC

In fact, the result of a class definition is a function:

#+BEGIN_SRC js :results values list :exports both
> typeof Point
'function'
#+END_SRC

However, you can only invoke a class via new, not via a function call (the rationale behind this is explained later):

#+BEGIN_SRC js :results values list :exports both
> Point()
TypeError: Classes can’t be function-called
#+END_SRC

#+BEGIN_QUOTE
In the spec, function-calling classes is prevented in the internal method [[Call]] of function objects.
#+END_QUOTE

*** No separators between members of class definitions
There is no separating punctuation between the members of a class definition.
For example, the members of an object literal are separated by commas, which are illegal at the top levels of class definitions. Semicolons are allowed, but ignored:

#+BEGIN_SRC js :results values list :exports both
class MyClass {
   foo() {}
   ; // OK, ignored
   , // SyntaxError
   bar() {}
}
#+END_SRC

semicolons are allowed in preparation for future syntax which may include semicolon-terminated members.
commas are forbidden to emphasize that class definitions are different from object literals.

*** class declarations are not hoisted
function declarations are hoisted: when entering a scope,
the functions that are declared in it are immediately available – independently of where the declarations happen. that means that you can call a function that is declared later:

#+BEGIN_SRC js :results values list :exports both
foo(); // works, because `foo` is hoisted

function foo() {}
#+END_SRC

in contrast, class declarations are not hoisted.
therefore, a class only exists after execution reached its definition and it was evaluated.
accessing it beforehand leads to a referenceerror:

#+BEGIN_SRC js :results values list :exports both
new foo(); // referenceerror

class foo {}
#+END_SRC

the reason for this limitation is that classes can have an extends clause whose value is an arbitrary expression.
that expression must be evaluated in the proper "location", its evaluation can’t be hoisted.
not having hoisting is less limiting than you may think.
for example, a function that comes before a class declaration can still refer to that class,
but you have to wait until the class declaration has been evaluated before you can call the function.

#+BEGIN_SRC js :results values list :exports both
function functionthatusesbar() {
    new bar();
}

functionthatusesbar(); // referenceerror
class bar {}
functionthatusesbar(); //
#+END_SRC
