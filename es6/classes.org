* Overview
A class and a subclass:

#+BEGIN_SRC js :results values list :exports both
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return `(${this.x}, ${this.y})`;
    }
}

class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y);
        this.color = color;
    }
    toString() {
        return super.toString() + ' in ' + this.color;
    }
}

#+END_SRC

Using the classes:

#+BEGIN_SRC js :results values list :exports both
> const cp = new ColorPoint(25, 8, 'green');
> cp.toString();
'(25, 8) in green'
> cp instanceof ColorPoint
true
> cp instanceof Point
true

#+END_SRC

Under the hood, ES6 classes are not something that is radically new: They mainly provide more convenient syntax to create old-school constructor functions. You can see that if you use typeof:


#+BEGIN_SRC js :results values list :exports both
> typeof Point
'function'
#+END_SRC

* The essentials
** Base classes
A class is defined like this in ECMAScript 6:

#+BEGIN_SRC js :results values list :exports both
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return `(${this.x}, ${this.y})`;
    }
}
#+END_SRC

You use this class just like an ES5 constructor function:

#+BEGIN_SRC js :results values list :exports both
> var p = new Point(25, 8);
> p.toString()
'(25, 8)'
#+END_SRC

In fact, the result of a class definition is a function:

#+BEGIN_SRC js :results values list :exports both
> typeof Point
'function'
#+END_SRC

However, you can only invoke a class via new, not via a function call (the rationale behind this is explained later):

#+BEGIN_SRC js :results values list :exports both
> Point()
TypeError: Classes can’t be function-called
#+END_SRC

#+BEGIN_QUOTE
In the spec, function-calling classes is prevented in the internal method [[Call]] of function objects.
#+END_QUOTE

*** No separators between members of class definitions
There is no separating punctuation between the members of a class definition.
For example, the members of an object literal are separated by commas, which are illegal at the top levels of class definitions. Semicolons are allowed, but ignored:

#+BEGIN_SRC js :results values list :exports both
class MyClass {
   foo() {}
   ; // OK, ignored
   , // SyntaxError
   bar() {}
}
#+END_SRC

semicolons are allowed in preparation for future syntax which may include semicolon-terminated members.
commas are forbidden to emphasize that class definitions are different from object literals.

*** class declarations are not hoisted
function declarations are hoisted: when entering a scope,
the functions that are declared in it are immediately available – independently of where the declarations happen. that means that you can call a function that is declared later:

#+BEGIN_SRC js :results values list :exports both
foo(); // works, because `foo` is hoisted

function foo() {}
#+END_SRC

in contrast, class declarations are not hoisted.
therefore, a class only exists after execution reached its definition and it was evaluated.
accessing it beforehand leads to a referenceerror:

#+BEGIN_SRC js :results values list :exports both
new foo(); // referenceerror

class foo {}
#+END_SRC

the reason for this limitation is that classes can have an extends clause whose value is an arbitrary expression.
that expression must be evaluated in the proper "location", its evaluation can’t be hoisted.
not having hoisting is less limiting than you may think.
for example, a function that comes before a class declaration can still refer to that class,
but you have to wait until the class declaration has been evaluated before you can call the function.

#+BEGIN_SRC js :results values list :exports both
function functionthatusesbar() {
    new bar();
}

functionthatusesbar(); // referenceerror
class bar {}
functionthatusesbar(); //
#+END_SRC

*** Class expressions
Similarly to functions, there are two kinds of class definitions,
two ways to define a class: class declarations and class expressions.
Similarly to function expressions, class expressions can be anonymous:

#+BEGIN_SRC js :results values list :exports both
const MyClass = class {
    ···
};
const inst = new MyClass();
#+END_SRC

Also similarly to function expressions,
class expressions can have names that are only visible inside them:


#+BEGIN_SRC js :results values list :exports both
const MyClass = class Me {
    getClassName() {
        return Me.name;
    }
};
const inst = new MyClass();

console.log(inst.getClassName()); // Me
console.log(Me.name); // ReferenceError: Me is not defined
#+END_SRC

The last two lines demonstrate that Me does not become a variable outside of the class,
but can be used inside it.
15.2.2 Inside the body of a class definition #
A class body can only contain methods, but not data properties. Prototypes having data properties is generally considered an anti-pattern, so this just enforces a best practice.

15.2.2.1 constructor, static methods, prototype methods
Let’s examine three kinds of methods that you often find in class definitions.

#+BEGIN_SRC js :results values list :exports both
class Foo {
    constructor(prop) {
        this.prop = prop;
    }
    static staticMethod() {
        return 'classy';
    }
    prototypeMethod() {
        return 'prototypical';
    }
}
const foo = new Foo(123);
#+END_SRC

The object diagram for this class declaration looks as follows.
Tip for understanding it: \[\[prototype\]\] is an inheritance relationship between objects,
while prototype is a normal property whose value is an object.
The property prototype is only special w.r.t. the new operator using its value as the prototype for instances it creates.
First, the pseudo-method *constructor*.
This method is special, as it defines the function that represents the class:

#+BEGIN_SRC js :results values list :exports both
> Foo === Foo.prototype.constructor
true
> typeof Foo
'function'
#+END_SRC

It is sometimes called a class constructor.
It has features that normal constructor functions don’t have (mainly the ability to constructor-call its superconstructor via super(), which is explained later).
Second, *static methods*. Static properties (or class properties) are properties of Foo itself. If you prefix a method definition with static, you create a class method:

#+BEGIN_SRC js :results values list :exports both
> typeof Foo.staticMethod
'function'
> Foo.staticMethod()
'classy'
#+END_SRC

Third, *prototype methods*. The prototype properties of Foo are the properties of Foo.prototype.
They are usually methods and inherited by instances of Foo.

#+BEGIN_SRC js :results values list :exports both
> typeof Foo.prototype.prototypeMethod
'function'
> foo.prototypeMethod()
'prototypical'
#+END_SRC
