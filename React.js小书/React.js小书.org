# -*- eval: (setq org-download-image-dir (concat default-directory "/screenshotImg")); -*-
#+LATEX_CLASS: my-article
* React.js 简介
React.js 是一个帮助你构建页面 UI 的库. 如果你熟悉 MVC 概念的话, 那么 React 的组件就
相当于 MVC 里面的 View. 如果你不熟悉也没关系, 你可以简单地理解为,React.js 将帮助
我们将界面分成了各个独立的小块, 每一个块就是组件, 这些组件之间可以组合, 嵌套, 就成
了我们的页面.

一个组件的显示形态和行为有可能是由某些数据决定的. 而数据是可能发生改变的, 这时候组
件的显示形态就会发生相应的改变. 而 React.js 也提供了一种非常高效的方式帮助我们做到
了数据和组件显示形态之间的同步.

React.js 不是一个框架, 它只是一个库. 它只提供 UI(view) 层面的解决方案. 在实际的项
目当中, 它并不能解决我们所有的问题, 需要结合其它的库, 例如 Redux,React-router 等来
协助提供完整的解决方法.

* 前端组件化(一): 从一个简单的例子讲起
很多课程一上来就给大家如何配置环境, 怎么写 React.js 组件. 但是本课程还是希望大家对问题的根源有一个更加深入的了解, 其实很多的库, 框架都是解决类似的问题. 只有我们对这些库, 框架解决的问题有深入的了解和思考以后, 我们才能得心应手地使用它们, 并且有新的框架出来也不会太过迷茫————因为其实它们解决都是同一个问题.

这两节课我们来探讨一下是什么样的问题导致了我们需要前端页面进行组件化, 前端页面的组件化需要解决什么样的问题. 后续课程我们再来看看 React.js 是怎么解决这些问题的.

所以这几节所讲的内容将和 React.js 的内容没有太大的关系, 但是如果你能顺利了解这几节的内容, 那么后面那些对新手来说很复杂的概念对你来说就是非常自然的事.

** 一个简单的点赞功能
 我们会从一个简单的点赞功能讲起. 假设现在我们需要实现一个点赞, 取消点赞的功能.

 [[file:screenshotImg/B7575C67-64F8-4A13-9C63-4D6805FA360D.png][file:screenshotImg/B7575C67-64F8-4A13-9C63-4D6805FA360D.png]]

 如果你对前端稍微有一点了解, 你就顺手拈来:

 #+BEGIN_SRC html
 <body>
     <div class='wrapper'>
         <button class='like-btn'>
             <span class='like-text'>点赞</span>
             <span>👍</span>
         </button>
     </div>
 </body>
 #+END_SRC

 为了模拟现实当中的实际情况, 所以这里特意把这个 button 里面的 HTML 结构搞得稍微复杂一些. 有了这个 HTML 结构, 现在就给它加入一些 JavaScript 的行为:

 #+BEGIN_SRC javascript
 const button = document.querySelector('.like-btn')
     const buttonText = button.querySelector('.like-text')
     let isLiked = false
     button.addEventListener('click', () => {
         isLiked = !isLiked
         if (isLiked) {
             buttonText.innerHTML = '取消'
         } else {
             buttonText.innerHTML = '点赞'
         }
     }, false)
 #+END_SRC

 功能和实现都很简单, 按钮已经可以提供点赞和取消点赞的功能. 这时候你的同事跑过来了, 说他很喜欢你的按钮, 他也想用你写的这个点赞功能. 这时候问题就来了, 你就会发现这种实现方式很致命: 你的同事要把整个 button 和里面的结构复制过去, 还有整段 JavaScript 代码也要复制过去. 这样的实现方式没有任何可复用性.

** 结构复用
 现在我们来重新编写这个点赞功能, 让它具备一定的可复用. 这次我们先写一个类, 这个类有 render 方法, 这个方法里面直接返回一个表示 HTML 结构的字符串:

 #+BEGIN_SRC javascript
 class LikeButton {
     render () {
       return `
           <button id='like-btn'>
               <span class='like-text'>赞</span>
               <span>👍</span>
           </button>
       `
    }
 }
 #+END_SRC

 然后可以用这个类来构建不同的点赞功能的实例, 然后把它们插到页面中.

 #+BEGIN_SRC javascript
 const wrapper = document.querySelector('.wrapper')
 const likeButton1 = new LikeButton()
 wrapper.innerHTML = likeButton1.render()

 const likeButton2 = new LikeButton()
 wrapper.innerHTML += likeButton2.render()
 #+END_SRC

 这里非常暴力地使用了 innerHTML , 把两个按钮粗鲁地插入了 wrapper 当中. 虽然你可能会对这种实现方式非常不满意, 但我们还是勉强了实现了结构的复用. 我们后面再来优化它.

** 实现简单的组件化
 你一定会发现, 现在的按钮是死的, 你点击它它根本不会有什么反应. 因为根本没有往上面添加事件. 但是问题来了, LikeButton 类里面是虽然说有一个 button, 但是这玩意根本就是在字符串里面的. 你怎么能往一个字符串里面添加事件呢?DOM 事件的 API 只有 DOM 结构才能用.

 我们需要 DOM 结构, 准确地来说: 我们需要这个点赞功能的 HTML 字符串表示的 DOM 结构. 假设我们现在有一个函数 =createDOMFromString=, 你往这个函数传入 HTML 字符串, 但是它会把相应的 DOM 元素返回给你. 这个问题就可以解决了.

 #+CAPTION: createDOMFromString
 #+BEGIN_SRC javascript
 // ::String => ::Document
 const createDOMFromString = (domString) => {
     const div = document.createElement('div')
     div.innerHTML = domString
     return div
 }
 #+END_SRC
 <<createDOMFromString>>

 先不用管这个函数应该怎么实现, 先知道它是干嘛的. 拿来用就好, 这时候用它来改写一下 LikeButton 类:

 #+CAPTION: render
 #+BEGIN_SRC javascript
 class LikeButton {
     render () {
         this.el = createDOMFromString(`
         <button class='like-button'>
             <span class='like-text'>点赞</span>
             <span>👍</span>
         </button>
         `)
         this.el.addEventListener('click', () => console.log('click'), false)
         return this.el
     }
 }
 #+END_SRC
 <<render>>

 现在 render() 返回的不是一个 html 字符串了, 而是一个由这个 html 字符串所生成的 DOM. 在返回 DOM 元素之前会先给这个 DOM 元素上添加事件再返回.

 因为现在 render 返回的是 DOM 元素, 所以不能用 innerHTML 暴力地插入 wrapper. 而是要用 =DOM API= 插进去.

 #+CAPTION: DOM API
 #+BEGIN_SRC javascript :results valuse list
 const wrapper = document.querySelector('.wrapper')

 const likeButton1 = new LikeButton()
 wrapper.appendChild(likeButton1.render())

 const likeButton2 = new LikeButton()
 wrapper.appendChild(likeButton2.render())
 #+END_SRC
 <<DOM API>>

 现在你点击这两个按钮, 每个按钮都会在控制台打印 click, 说明事件绑定成功了.
 但是按钮上的文本还是没有发生改变, 只要稍微改动一下 LikeButton 的代码就可以完成完整的功能:

 #+BEGIN_SRC javascript
 class LikeButton {
     constructor () {
         this.state = { isLiked: false }
     }

     changeLikeText () {
         const likeText = this.el.querySelector('.like-text')
         this.state.isLiked = !this.state.isLiked
         likeText.innerHTML = this.state.isLiked ? '取消' : '点赞'
     }

     render () {
         this.el = createDOMFromString(`
         <button class='like-button'>
           <span class='like-text'>点赞</span>
           <span>👍</span>
         </button>
         `)
         this.el.addEventListener('click', this.changeLikeText.bind(this), false)
         return this.el
     }
 }
 #+END_SRC

 这里的代码稍微长了一些, 但是还是很好理解. 只不过是在给 LikeButton 类添加了构造函数, 这个构造函数会给每一个 LikeButton 的实例添加一个对象 state,state 里面保存了每个按钮自己是否点赞的状态. 还改写了原来的事件绑定函数: 原来只打印 click, 现在点击的按钮的时候会调用 changeLikeText 方法, 这个方法会根据 this.state 的状态改变点赞按钮的文本.

 现在这个组件的可复用性已经很不错了, 你的同事们只要实例化一下然后插入到 DOM 里面去就好了.

 下一节我们继续优化这个例子, 让它更加通用.

* 前端组件化(二): 优化 DOM 操作
看看上一节我们的代码, 仔细留意一下 changeLikeText 函数, 这个函数包含了 DOM 操作, 现在看起来比较简单, 那是因为现在只有 isLiked 一个状态. 由于数据状态改变会导致需要我们去更新页面的内容, 所以假想一下, 如果你的组件依赖了很多状态, 那么你的组件基本全部都是 DOM 操作.

一个组件的显示形态由多个状态决定的情况非常常见. 代码中混杂着对 DOM 的操作其实是一种不好的实践, 手动管理数据和 DOM 之间的关系会导致代码可维护性变差, 容易出错. 所以我们的例子这里还有优化的空间: 如何尽量减少这种手动 DOM 操作?

** 状态改变 -> 构建新的 DOM 元素更新页面
 这里要提出的一种解决方案: 一旦状态发生改变, 就重新调用 render 方法, 构建一个新的 DOM 元素. 这样做的好处是什么呢? 好处就是你可以在 render 方法里面使用最新的 this.state 来构造不同 HTML 结构的字符串, 并且通过这个字符串构造不同的 DOM 元素. 页面就更新了! 听起来有点绕, 看看代码怎么写, 修改原来的代码为:

 #+BEGIN_SRC javascript
 class LikeButton {
     constructor () {
         this.state = { isLiked: false }
     }

     setState (state) {
         this.state = state
         this.el = this.render()
     }

     changeLikeText () {
         this.setState({
             isLiked: !this.state.isLiked
         })
     }

     render () {
         this.el = createDOMFromString(`
         <button class='like-btn'>
           <span class='like-text'>${this.state.isLiked ? '取消' : '点赞'}</span>
           <span>👍</span>
         </button>
         `)
         this.el.addEventListener('click', this.changeLikeText.bind(this), false)
         return this.el
     }
 }
 #+END_SRC
 [[createDOMFromString][See createDOMFromString]]

 其实只是改了几个小地方:
 render 函数里面的 HTML 字符串会根据 this.state 不同而不同(这里是用了 ES6 的模版字符串, 做这种事情很方便).
 新增一个 =setState= 函数, 这个函数接受一个对象作为参数, 它会设置实例的 state, 然后重新调用一下 render 方法.
 当用户点击按钮的时候, =changeLikeText= 会构建新的 state 对象, 这个新的 state, 传入 setState 函数当中.
 这样的结果就是, 用户每次点击, =changeLikeText= 都会调用改变组件状态然后调用 setState,setState 会调用 render,render 方法会根据 state 的不同重新构建不同的 DOM 元素.

 也就是说, 你只要调用 setState, 组件就会重新渲染. 我们顺利地消除了手动的 DOM 操作.

** 重新插入新的 DOM 元素
 上面的改进不会有什么效果, 因为你仔细看一下就会发现, 其实重新渲染的 DOM 元素并没有插入到页面当中. 所以在这个组件外面, 你需要知道这个组件发生了改变, 并且把新的 DOM 元素更新到页面当中.

 重新修改一下 =setState= 方法:

 #+CAPTION: setState
 #+BEGIN_SRC javascript
 ...
     setState (state) {
         const oldEl = this.el
         this.state = state
         this.el = this.render()
         if (this.onStateChange) this.onStateChange(oldEl, this.el)
     }
 ...
 #+END_SRC
 <<setState>>

 使用这个组件的时候:

 #+BEGIN_SRC javascript
 const likeButton = new LikeButton()
 wrapper.appendChild(likeButton.render()) // 第一次插入 DOM 元素
 likeButton.onStateChange = (oldEl, newEl) => {
     wrapper.insertBefore(newEl, oldEl) // 插入新的元素
     wrapper.removeChild(oldEl) // 删除旧的元素
 }
 #+END_SRC
 <<onStateChange>>

 这里每次 =setState= 都会调用 =onStateChange= 方法, 而这个方法是实例化以后时候被设置的, 所以你可以自定义 =onStateChange= 的行为. 这里做的事是, 每当 =setState= 中构造完新的 DOM 元素以后, 就会通过 =onStateChange= 告知外部插入新的 DOM 元素, 然后删除旧的元素, 页面就更新了.
 这里已经做到了进一步的优化了: 现在不需要再手动更新页面了.

 非一般的暴力, 因为每次 =setState= 都重新构造, 新增, 删除 DOM 元素, 会导致浏览器进行大量的重排, 严重影响性能. 不过没有关系, 这种暴力行为可以被一种叫 =Virtual-DOM= 的策略规避掉, 但这不是本文所讨论的范围.

 这个版本的点赞功能很不错, 我可以继续往上面加功能, 而且还不需要手动操作 DOM. 但是有一个不好的地方, 如果我要重新另外做一个新组件, 譬如说评论组件, 那么里面的这些 =setState= 方法要重新写一遍, 其实这些东西都可以抽出来, 变成一个通用的模式. 下一节我们把这个通用模式抽离到一个类当中.

* 前端组件化(三): 抽象出公共组件类
为了让代码更灵活, 可以写更多的组件, 我们把这种模式抽象出来, 放到一个 Component 类当中:

#+CAPTION: _renderDOM
#+BEGIN_SRC javascript
class Component {
    setState (state) {
        const oldEl = this.el
        this.state = state
        this._renderDOM()
        if (this.onStateChange) this.onStateChange(oldEl, this.el)
    }

    _renderDOM () {
        this.el = createDOMFromString(this.render())
        if (this.onClick) {
            this.el.addEventListener('click', this.onClick.bind(this), false)
        }
        return this.el
    }
}
#+END_SRC
<<_renderDOM>>
[[createDOMFromString][
See createDOMFromString]]

[[%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84 render %E6%96%B9%E6%B3%95][See 返回字符串的 render 方法]]

[[setState][See setState]]

这个是一个组件父类 Component, 所有的组件都可以继承这个父类来构建. 它定义的两个方法, 一个是我们已经很熟悉的 setState, 一个是私有方法 =_renderDOM=.
=_renderDOM= 方法会调用 this.render 来构建 DOM 元素并且监听 onClick 事件.
= 所以, 组件子类继承的时候只需要实现一个返回 HTML 字符串的 render 方法就可以了.=

还有一个额外的 =mount= 的方法, 其实就是把组件的 DOM 元素插入页面, 并且在 setState 的时候更新页面:

#+CAPTION: mount
#+BEGIN_SRC javascript
const mount = (component, wrapper) => {
    wrapper.appendChild(component._renderDOM())
    component.onStateChange = (oldEl, newEl) => {
        wrapper.insertBefore(newEl, oldEl)
        wrapper.removeChild(oldEl)
    }
}
#+END_SRC
<<mount>>

[[onStateChange][See onStateChange]]

这样的话我们重新写点赞组件就会变成:

#+CAPTION: 返回字符串的 render 方法
#+BEGIN_SRC javascript
class LikeButton extends Component {
    constructor () {
        super()
        this.state = { isLiked: false }
    }

    onClick () {
        this.setState({
            isLiked: !this.state.isLiked
        })
    }

    render () {
        return `
        <button class='like-btn'>
          <span class='like-text'>${this.state.isLiked ? '取消' : '点赞'}</span>
          <span>👍</span>
        </button>
      `
    }
}

mount(new LikeButton(), wrapper)
#+END_SRC
<<返回字符串的 render 方法>>

[[_renderDOM][See _renderDOM]]

这样还不够好. 在实际开发当中, 你可能需要给组件传入一些自定义的配置数据. 例如说想配置一下点赞按钮的背景颜色, 如果我给它传入一个参数, 告诉它怎么设置自己的颜色. 那么这个按钮的定制性就更强了. 所以我们可以给组件类和它的子类都传入一个参数 props, 作为组件的配置参数. 修改 Component 的构造函数为:

#+BEGIN_SRC javascript
...
    constructor (props = {}) {
        this.props = props
    }
...
#+END_SRC

继承的时候通过 super(props) 把 props 传给父类, 这样就可以通过 this.props 获取到配置参数:

#+CAPTION: 支持读取 props 参数的 render 方法
#+BEGIN_SRC javascript
class LikeButton extends Component {
    constructor (props) {
        super(props)
        this.state = { isLiked: false }
    }

    onClick () {
        this.setState({
            isLiked: !this.state.isLiked
        })
    }

    render () {
        return `
        <button class='like-btn' style="background-color: ${this.props.bgColor}">
          <span class='like-text'>
            ${this.state.isLiked ? '取消' : '点赞'}
          </span>
          <span>👍</span>
        </button>
      `
    }
}

mount(new LikeButton({ bgColor: 'red' }), wrapper)
#+END_SRC
<<支持读取 props 参数的 render 方法>>

这里我们稍微修改了一下原有的 LikeButton 的 =render= 方法, 让它可以根据传入的参数 =this.props.bgColor= 来生成不同的 style 属性. 这样就可以自由配置组件的颜色了.

只要有了上面那个 =Component= 类和 =mount= [[mount][See mount ]] 方法加起来不足 40 行代码就可以做到组件化. 如果我们需要写另外一个组件, 只需要像上面那样, 简单地继承一下 Component 类就好了:

#+BEGIN_SRC javascript
class RedBlueButton extends Component {
    constructor (props) {
        super(props)
        this.state = {
            color: 'red'
        }
    }

    onClick () {
        this.setState({
            color: 'blue'
        })
    }

    render () {
        return `
        <div style='color: ${this.state.color};'>${this.state.color}</div>
      `
    }
}
#+END_SRC

简单好用, 现在可以灵活地组件化页面了.Component 完整的代码可以在这里找到.

#+CAPTION: reactjs-in-40
#+BEGIN_SRC html
<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <title>Reactjs in 40 </title>
    <style media="screen">
      .like-btn { font-size: 50px; }
    </style>
  </head>

  <body>
    <div class='wrapper'></div>
  </body>

  <script type="text/javascript">
    /* Component */
    class Component {
      constructor (props = {}) {
        this.props = props
      }
      setState (state) {
        const oldEl = this.el
        this.state = state
        this.el = this.renderDOM()
        if (this.onStateChange) this.onStateChange(oldEl, this.el)
      }
      renderDOM () {
        this.el = createDOMFromString(this.render())
        if (this.onClick) {
          this.el.addEventListener('click', this.onClick.bind(this), false)
        }
        return this.el
      }
    }
    const createDOMFromString = (domString) => {
      const div = document.createElement('div')
      div.innerHTML = domString
      return div
    }
    const mount = (component, wrapper) => {
      wrapper.appendChild(component.renderDOM())
      component.onStateChange = (oldEl, newEl) => {
        wrapper.insertBefore(newEl, oldEl)
        wrapper.removeChild(oldEl)
      }
    }
    /* ========================================= */
    class LikeButton extends Component {
      constructor (props) {
        super(props)
        this.state = { isLiked: false }
      }
      onClick () {
        this.setState({
          isLiked: !this.state.isLiked
        })
      }
      render () {
        return `
          <button class='like-btn' style="background-color: ${this.props.bgColor}">
            <span class='like-text'>
              ${this.state.isLiked ? '取消' : '点赞'}
            </span>
            <span>👍</span>
          </button>
        `
      }
    }
    class RedBlueButton extends Component {
      constructor (props) {
        super(props)
        this.state = {
          color: 'red'
        }
      }
      onClick () {
        this.setState({
          color: 'blue'
        })
      }
      render () {
        return `
          <div style='color: ${this.state.color};'>${this.state.color}</div>
        `
      }
    }
    const wrapper = document.querySelector('.wrapper')
    mount(new LikeButton({ bgColor: 'red' }), wrapper)
    mount(new LikeButton(), wrapper)
    mount(new RedBlueButton(), wrapper)
  </script>
</html>
#+END_SRC
<<reactjs-in-40>>

** 总结
 我们用了很长的篇幅来讲一个简单的点赞的例子, 并且在这个过程里面一直在优化编写的方式. 最后抽离出来了一个类, 可以帮助我们更好的做组件化. 在这个过程里面我们学到了什么?

 组件化可以帮助我们解决前端结构的复用性问题, 整个页面可以由这样的不同的组件组合, 嵌套构成.

 一个组件有自己的显示形态(上面的 HTML 结构和内容) 行为, 组件的显示形态和行为可以由数据状态(state) 和配置参数(props) 共同决定. 数据状态和配置参数的改变都会影响到这个组件的显示形态.

 当数据变化的时候, 组件的显示需要更新. 所以如果组件化的模式能提供一种高效的方式自动化地帮助我们更新页面, 那也就可以大大地降低我们代码的复杂度, 带来更好的可维护性.

 好了, 课程结束了. 你已经学会了怎么使用 React.js 了, 因为我们已经写了一个——当然我是在开玩笑, 但是上面这个 Component 类其实和 React 的 Component 使用方式很类似. 掌握了这几节的课程, 你基本就掌握了基础的 React.js 的概念.

 接下来我们开始正式进入主题, 开始正式介绍 React.js. 你会发现, 有了前面的铺垫, 下面讲的内容理解起来会简单很多了.

* React.js 基本环境安装
** 安装 React.js
 React.js 单独使用基本上是不可能的事情. 不要指望着类似于 jQuery 下载放到 <head/> 标签就开始使用.
 使用 React.js 不管在开发阶段生产阶段都需要一堆工具和库辅助, 编译阶段你需要借助 Babel, 需要 Redux 等第三方的状态管理工具来组织代码, 如果你要写单页面应用那么你需要 React-router. 这就是所谓的"React.js 全家桶".

 本课程不会教大家如何配置这些东西, 因为这不是课程的重点, 网上有很多的资料, 大家可以去参考那些资料.
 我们这里会直接使用 React.js 官网所推荐使用的工具 create-react-app 工具.
 它可以帮助我们一键生成所需要的工程目录, 并帮我们做好各种配置和依赖, 也帮我们隐藏了这些配置的细节. 也就是所谓的" 开箱即用".

 工具地址:https://github.com/facebookincubator/create-react-app

 [[file:screenshotImg/C9754D1A-0989-49B2-AC9F-B8D9717198CB.png]]

 在安装之前要确认你的机器上安装了 node.js 环境包括 npm. 如果没有安装的同学可以到 node.js 的官网下载自己电脑的对应的安装包来安装好环境.

 安装好环境以后, 只需要按照官网的指引安装 create-react-app 即可.

 #+BEGIN_SRC javascript :results valuse list :exports both
 npm install -g create-react-app
 #+END_SRC

 这条命令会往我们的机器上安装一条叫 =create-react-app= 的命令, 安装好以后就可以直接使用它来构建一个 react 的前端工程:

 #+BEGIN_SRC javascript :results valuse list :exports both
 create-react-app hello-react
 #+END_SRC

 这条命令会帮我们构建一个叫 hello-react 的工程, 并且会自动地帮助我们安装所需要的依赖, 现在只需要安静地等待它安装完.

 #+BEGIN_QUOTE
 额外的小贴士:

 如果有些同学安装过程比较慢, 那是很有可能是因为 npm 下载的时候是从国外的源下载的缘故. 所以可以把 npm 的源改成国内的 taobao 的源, 这样会加速下载过程. 在执行上面的命令之前可以先修改一下 npm 的源:

 #+BEGIN_SRC javascript :results valuse list :exports both
 npm config set registry https://registry.npm.taobao.org
 #+END_SRC

 #+END_QUOTE

 下载完以后我们就可以启动工程了, 进入工程目录然后通过 npm 启动工程:

 #+BEGIN_SRC javascript :results valuse list :exports both
 cd hello-react
 npm start
 #+END_SRC

 终端提示成功:

 [[file:screenshotImg/C9754D1A-0989-49B2-AC9F-B8D9717198CB.png]]

 并且会自动打开浏览器, 就可以看到 React 的工程顺利运行的效果:

 [[file:screenshotImg/React_App.png]]

 这时候我们把 src/App.js 文件中的 <h2> 标签的内容修改为 Hello React,

 #+BEGIN_SRC javascript :results valuse list :exports both
     <h2>Hello React</h2>
 #+END_SRC

 保存一下, 然后户就会发现浏览器自动刷新, 并且我们的修改也生效了:

 [[file:screenshotImg/3FDC1B75-AACD-40A4-9101-1AF8C57EFBF4.png]]

 到这里我们的环境已经安装好了, 并且顺利地运行了我们第一个例子. 接下来我们会探讨 React.js 的组件的基本写法.

* 使用 JSX 描述 UI 信息
这一节我们通过一个简单的例子讲解 React.js 描述页面 UI 的方式. 把 src/index.js 中的代码改成:
#+BEGIN_SRC javascript :results valuse list :exports both
import React, { Component } from 'react'
import ReactDOM from 'react-dom'
import './index.css'

class Header extends Component {
   render () {
       return (
               <div>
                 <h1>React 小书</h1>
               </div>
       )
   }
}

ReactDOM.render(
   <Header />,
   document.getElementById('root')
)
#+END_SRC

我们在文件头部从 react 的包当中引入了 React 和 React.js 的组件父类 Component. 记住, 只要你要写 React.js 组件, 那么就必须要引入这两个东西.

ReactDOM 可以帮助我们把 React 组件渲染到页面上去, 没有其它的作用了. 你可以发现它是从 react-dom 中引入的, 而不是从 react 引入. 有些朋友可能会疑惑, 为什么不把这些东西都包含在 react 包当中呢? 我们稍后会回答这个问题.

接下来的代码你看起来会比较熟悉, 但又会有点陌生. 你看其实它跟我们前几节里面讲的内容其实很类似, 一个组件继承 Component 类, 有一个 render 方法, 并且把这个组件的 HTML 结构返回, 这里 return 的东西就比较奇怪了, 它并不是一个字符串, 看起来像是纯 HTML 代码写在 JavaScript 代码里面. 你也许会说, 这不就有语法错误了么? 这完全不是合法的 JavaScript 代码. 这种看起来" 在 JavaScript 写的标签的" 语法叫 JSX.

** JSX 原理
 为了让大家深刻理解 JSX 的含义. 有必要简单介绍了一下 JSX 稍微底层的运作原理, 这样大家可以更加深刻理解 JSX 到底是什么东西, 为什么要有这种语法, 它是经过怎么样的转化变成页面的元素的.

 思考一个问题: 如何用 JavaScript 对象来表现一个 DOM 元素的结构, 举个例子:

 #+BEGIN_SRC javascript :results valuse list :exports both
 <div class='box' id='content'>
 <div class='title'>Hello</div>
 <button>Click</button>
 </div>
 #+END_SRC

 每个 DOM 元素的结构都可以用 JavaScript 的对象来表示. 你会发现一个 DOM 元素包含的信息其实只有三个: 标签名, 属性, 子元素.

 所以其实上面这个 HTML 所有的信息我们都可以用合法的 JavaScript 对象来表示:

 #+BEGIN_SRC javascript :results valuse list :exports both
 {
     tag: 'div',
     attrs: { className: 'box', id: 'content'},
     children: [
         {
             tag: 'div',
             arrts: { className: 'title' },
             children: ['Hello']
         },
         {
             tag: 'button',
             attrs: null,
             children: ['Click']
         }
     ]
 }
 #+END_SRC

 你会发现,HTML 的信息和 JavaScript 所包含的结构和信息其实是一样的, 我们可以用 JavaScript 对象来描述所有能用 HTML 表示的 UI 信息.
 但是用 JavaScript 写起来太长了, 结构看起来又不清晰, 用 HTML 的方式写起来就方便很多了.

 于是 React.js 就把 JavaScript 的语法扩展了一下, 让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法, 这样写起来就方便很多了. 编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构.

 上面的代码:

 #+BEGIN_SRC javascript :results valuse list :exports both
 import React, { Component } from 'react'
 import ReactDOM from 'react-dom'
 import './index.css'

 class Header extends Component {
     render () {
         return (
                 <div>
                 <h1 className='title'>React 小书</h1>
                 </div>
         )
     }
 }

 ReactDOM.render(
     <Header />,
     document.getElementById('root')
 )
 #+END_SRC

 经过编译以后会变成:

 #+BEGIN_SRC javascript :results valuse list :exports both
 import React, { Component } from 'react'
 import ReactDOM from 'react-dom'
 import './index.css'

 class Header extends Component {
     render () {
         return (
             React.createElement(
                 "div",
                 null,
                 React.createElement(
                     "h1",
                     { className: 'title' },
                     "React 小书"
                 )
             )
         )
     }
 }

 ReactDOM.render(
     React.createElement(Header, null),
     document.getElementById('root')
 );
 #+END_SRC

 React.createElement 会构建一个 JavaScript 对象来描述你 HTML 结构的信息, 包括标签名, 属性, 还有子元素等.
 这样的代码就是合法的 JavaScript 代码了. 所以使用 React 和 JSX 的时候一定要经过编译的过程.

 这里再重复一遍: 所谓的 JSX 其实就是 JavaScript 对象.
 每当在 JavaScript 代码中看到这种 JSX 结构的时候, 脑子里面就可以自动做转化, 这样对你理解 React.js 的组件写法很有好处.

 有了这个表示 HTML 结构和信息的对象以后, 就可以拿去构造真正的 DOM 元素, 然后把这个 DOM 元素塞到页面上.
 这也是我们最后一段代码中 ReactDOM.render 所干的事情:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ReactDOM.render(
         <Header />,
     document.getElementById('root')
 )
 #+END_SRC

 ReactDOM.render 功能就是把组件渲染并且构造 DOM 树, 然后插入到页面上某个特定的元素上(在这里是 id 为 root 的 div 元素).

 所以可以总结一下从 JSX 到页面到底经过了什么样的过程:

 [[file:screenshotImg/44B5EC06-EAEB-4BA2-B3DC-325703E4BA45.png]]

 有些同学可能会问, 为什么不直接从 JSX 直接渲染构造 DOM 结构, 而是要经过中间这么一层呢?

 第一个原因是, 当我们拿到一个表示 UI 的结构和信息的对象以后, 不一定会把元素渲染到浏览器的普通页面上, 我们有可能把这个结构渲染到 canvas 上, 或者是手机 App 上. 所以这也是为什么会要把 react-dom 单独抽离出来的原因, 可以想象有一个叫 react-canvas 可以帮我们把 UI 渲染到 canvas 上, 或者是有一个叫 react-app 可以帮我们把它转换成原生的 App(实际上这玩意叫 ReactNative).

 第二个原因是, 有了这样一个对象. 当数据变化, 需要更新组件的时候, 就可以用比较快的算法操作这个 JavaScript 对象, 而不用直接操作页面上的 DOM, 这样可以尽量少的减少浏览器重排, 极大地优化性能. 这个在以后的章节中我们会提到.

** 总结
 要记住几个点:
 - JSX 是 JavaScript 语言的一种语法扩展, 长得像 HTML, 但并不是 HTML.
 - React.js 可以用 JSX 来描述你的组件长什么样的.
 - JSX 在编译的时候会变成相应的 JavaScript 对象描述.
 - react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素, 并且渲染到页面上.

* 组件的 render 方法
React.js 中一切皆组件, 用 React.js 写的其实就是 React.js 组件. 我们在编写 React.js 组件的时候, 一般都需要继承 React.js 的 Component(还有别的编写组件的方式我们后续会提到).
一个组件类必须要实现一个 =render= 方法, 这个 render 方法必须要返回一个 JSX 元素.
但这里要注意的是, 必须要用一个外层的 JSX 元素把所有内容包裹起来. 返回并列多个 JSX 元素是不合法的, 下面是错误的做法:

#+BEGIN_SRC javascript :results valuse list :exports both
...
    render () {
        return (
            <div>第一个</div>
            <div>第二个</div>
        )
    }
...
#+END_SRC

必须要用一个外层元素把内容进行包裹:

#+BEGIN_SRC javascript :results valuse list :exports both
...
    render () {
        return (
            <div>
                <div>第一个</div>
                <div>第二个</div>
            </div>
        )
    }
...
#+END_SRC

** 表达式插入
 在 JSX 当中你可以插入 JavaScript 的表达式, 表达式返回的结果会相应地渲染到页面上. 表达式用 {} 包裹. 例如:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const word = 'is good'
         return (
             <div>
                 <h1>React 小书 {word}</h1>
             </div>
       )
     }
 ...
 #+END_SRC

 页面上就显示"React 小书 is good". 你也可以把它改成 ={1 + 2}=, 它就会显示 "React 小书 3". 你也可以把它写成一个函数表达式返回:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         return (
             <div>
                 <h1>React 小书 {(function () { return 'is good'})()}</h1>
             </div>
         )
     }
 ...
 #+END_SRC

 简而言之,{} 内可以放任何 JavaScript 的代码, 包括变量, 表达式计算, 函数执行等等. =render= 会把这些代码返回的内容如实地渲染到页面上, 非常的灵活.

 = 表达式插入不仅仅可以用在标签内部, 也可以用在标签的属性上,= 例如:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const className = 'header'
         return (
             <div className={className}>
                 <h1>React 小书</h1>
             </div>
         )
     }
 ...
 #+END_SRC

 这样就可以为 div 标签添加一个叫 header 的类名.

 注意, 直接使用 class 在 React.js 的元素上添加类名如 <div class="xxx"> 这种方式是不合法的.
 因为 class 是 JavaScript 的关键字, 所以 React.js 中定义了一种新的方式: =className= 来帮助我们给元素添加类名.

 还有一个特例就是 for 属性, 例如 <label for='male'>Male</label>, 因为 for 也是 JavaScript 的关键字, 所以在 JSX 用 =htmlFor= 替代, 即 <label htmlFor='male'>Male</label>. 而其他的 HTML 属性例如 style ,data-* 等就可以像普通的 HTML 属性那样直接添加上去.

** 条件返回
 {} 上面说了,JSX 可以放置任何表达式内容. 所以也可以放 JSX, 实际上, 我们可以在 render 函数内部根据不同条件返回不同的 JSX. 例如:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const isGoodWord = true
         return (
             <div>
                 <h1>
                     React 小书
                     {isGoodWord
                      ? <strong> is good</strong>
                      : <span> is not good</span>
                     }
               </h1>
             </div>
         )
     }
 ...
 #+END_SRC

 上面的代码中定义了一个 isGoodWord 变量为 true, 下面有个用 {} 包含的表达式, 根据 isGoodWord 的不同返回不同的 JSX 内容.
 现在页面上是显示 React 小书 is good. 如果你把 isGoodWord 改成 false 然后再看页面上就会显示 React 小书 is not good.

 如果你在表达式插入里面返回 null , 那么 React.js 会什么都不显示, 相当于忽略了该表达式插入. 结合条件返回的话, 我们就做到显示或者隐藏某些元素:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const isGoodWord = true
         return (
             <div>
                 <h1>
                   React 小书
                   {isGoodWord
                    ? <strong> is good</strong>
                    : null
                   }
                 </h1>
             </div>
         )
     }
 ...
 #+END_SRC

 这样就相当于在 isGoodWord 为 true 的时候显示 <strong>is good</strong>, 否则就隐藏.

 条件返回 JSX 的方式在 React.js 中很常见, 组件的呈现方式随着数据的变化而不一样, 你可以利用 JSX 这种灵活的方式随时组合构建不同的页面结构.

 如果这里有些同学觉得比较难理解的话, 可以回想一下, 其实 JSX 就是 JavaScript 里面的对象, 转换一下角度, 把上面的内容翻译成 JavaScript 对象的形式, 上面的代码就很好理解了.

** JSX 元素变量
 同样的, 如果你能理解 JSX 元素就是 JavaScript 对象. 那么你就可以联想到, =JSX 元素其实可以像 JavaScript 对象那样自由地赋值给变量, 或者作为函数参数传递, 或者作为函数的返回值.=

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const isGoodWord = true
         const goodWord = <strong> is good</strong>
         const badWord = <span> is not good</span>
           return (
               <div>
                   <h1>
                     React 小书
                     {isGoodWord ? goodWord : badWord}
                   </h1>
               </div>
       )
 }
 ...
 #+END_SRC

 这里给把两个 JSX 元素赋值给了 goodWord 和 badWord 两个变量, 然后把它们作为表达式插入的条件返回值. 达到效果和上面的例子一样, 随机返回不同的页面效果呈现.

 再举一个例子:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     renderGoodWord (goodWord, badWord) {
         const isGoodWord = true
         return isGoodWord ? goodWord : badWord
     }

 render () {
     return (
         <div>
             <h1>
                 React 小书
                 {this.renderGoodWord(
                     <strong> is good</strong>,
                     <span> is not good</span>
                 )}
             </h1>
         </div>
     )
 }
 ...
 #+END_SRC

这里我们定义了一个 renderGoodWord 函数, 这个函数接受两个 JSX 元素作为参数, 并且随机返回其中一个.
在 render 方法中, 我们把上面例子的两个 JSX 元素传入 renderGoodWord 当中, 通过表达式插入把该函数返回的 JSX 元素插入到页面上.
用 React.js 构建未读消息组件

** 使用 React.js 构建一个未读消息组件 Notification.
 通过 getNotificationsCount() 来获取未读消息的数量 , 如果有未读消息 N 条, 而且 N > 0, 那么 Notification 组件渲染显示:

 #+BEGIN_QUOTE
 <span>有(N) 条未读消息</span>
 #+END_QUOTE

 否则显示:

 #+BEGIN_QUOTE
 <span>没有未读消息</span>
 #+END_QUOTE

 #+BEGIN_SRC javascript :results valuse list :exports both
 // 函数 getNotificationsCount 已经可以直接调用

 class Notification extends Component {
     render () {
         const N = getNotificationsCount()
         return(
                 <div>
                     {N>0?<span>有({N}) 条未读消息</span>:<span>没有未读消息</span>}
                 </div>
         )
     }
 }
 #+END_SRC

 或者

 #+BEGIN_SRC javascript :results valuse list :exports both
 // 函数 getNotificationsCount 已经可以直接调用

 class Notification extends Component {
     render () {
         // TODO
         let N = getNotificationsCount()
         return (
                 <div>
                     <span>{N>0?`有(${N}) 条未读消息`:`没有未读消息`}</span>
                 </div>
         )
     }
 }
 #+END_SRC

* 组件的组合, 嵌套和组件树
继续拓展前面的例子, 现在我们已经有了 Header 组件了.
假设我们现在构建一个新的组件叫 Title, 它专门负责显示标题. 你可以在 Header 里面使用 Title 组件:

#+BEGIN_SRC javascript :results valuse list :exports both
class Title extends Component {
    render () {
        return (
            <h1>React 小书</h1>
        )
    }
}

class Header extends Component {
    render () {
        return (
            <div>
                <Title />
            </div>
        )
    }
}
#+END_SRC

我们可以直接在 Header 标签里面直接使用 Title 标签.
就像是一个普通的标签一样.React.js 会在 <Title /> 所在的地方把 Title 组件的 render 方法表示的 JSX 内容渲染出来, 也就是说 <h1>React 小书</h1> 会显示在相应的位置上.
如果现在我们在 Header 里面使用三个 <Title /> , 那么就会有三个 <h1 /> 显示在页面上.

#+BEGIN_SRC javascript :results valuse list :exports both
<div>
    <Title />
    <Title />
    <Title />
</div>
#+END_SRC

这样可复用性非常强, 我们可以把组件的内容封装好, 然后灵活在使用在任何组件内.
另外这里要注意的是, =自定义的组件都必须要用大写字母开头=, 普通的 HTML 标签都用小写字母开头.

现在让组件多起来. 我们来构建额外的组件来构建页面, 假设页面是由 Header,Main,Footer 几个部分组成, 由一个 Index 把它们组合起来.

#+BEGIN_SRC javascript :results valuse list :exports both
import React, { Component } from 'react';
import ReactDOM from 'react-dom';

class Title extends Component {
    render () {
        return (
            <h1>React 小书</h1>
        )
    }
}

class Header extends Component {
    render () {
        return (
            <div>
                <Title />
                <h2>This is Header</h2>
            </div>
        )
    }
}

class Main extends Component {
    render () {
        return (
            <div>
                <h2>This is main content</h2>
            </div>
        )
    }
}

class Footer extends Component {
    render () {
        return (
            <div>
                <h2>This is footer</h2>
            </div>
        )
    }
}

class Index extends Component {
    render () {
        return (
            <div>
                <Header />
                <Main />
                <Footer />
            </div>
        )
    }
}

ReactDOM.render
    <Index />,
    document.getElementById('root')
)
#+END_SRC

最后页面会显示内容:

[[file:screenshotImg/D57824A9-3F1F-44ED-9CFF-478902261653.png]]

组件可以和组件组合在一起, 组件内部可以使用别的组件.
就像普通的 HTML 标签一样使用就可以.
这样的组合嵌套, 最后构成一个所谓的组件树, 就正如上面的例子那样,Index 用了 Header,Main,Footer,Header 又使用了 Title.
这样用这样的树状结构表示它们之间的关系:

[[file:screenshotImg/19BBE4E2-A12E-4657-BA6A-61484F67FA60.png]]

这里的结构还是比较简单, 因为我们的页面结构并不复杂.
当页面结构复杂起来, 有许多不同的组件嵌套组合的话, 组件树会相当的复杂和庞大.
理解组件树的概念对后面理解数据是如何在组件树内自上往下流动过程很重要.

* 事件监听
在 React.js 里面监听事件是很容易的事情, 你只需要给需要监听事件的元素加上属性类似于 onClick,onKeyDown 这样的属性, 例如我们现在要给 Title 加上点击的事件监听:

#+BEGIN_SRC javascript :results valuse list :exports both
class Title extends Component {
    handleClickOnTitle () {
        console.log('Click on title.')
    }

    render () {
        return (
            <h1 onClick={this.handleClickOnTitle}>React 小书</h1>
        )
    }
}
#+END_SRC

只需要给 h1 标签加上 onClick 的事件, =onClick 紧跟着是一个表达式插入, 这个表达式返回一个 Title 自己的一个实例方法.=
当用户点击 h1 的时候,React.js 就会调用这个方法, 所以你在控制台就可以看到 Click on title. 打印出来.

在 React.js 不需要手动调用浏览器原生的 addEventListener 进行事件监听.
React.js 帮我们封装好了一系列的 on* 的属性, 当你需要为某个元素监听某个事件的时候, 只需要简单地给它加上 on* 就可以了.
而且你不需要考虑不同浏览器兼容性的问题,React.js 都帮我们封装好这些细节了.

React.js 封装了不同类型的事件, 这里就不一一列举, 有兴趣的同学可以参考官网文档:[[https://reactjs.org/docs/events.html#supported-events][SyntheticEvent - React]], 多尝试不同的事件.
另外要注意的是, 这些事件属性名都必须要用驼峰命名法.

=没有经过特殊处理的话, 这些 on* 的事件监听只能用在普通的 HTML 的标签上, 而不能用在组件标签上. 也就是说,<Header onClick={…} /> 这样的写法不会有什么效果的.=
这一点要注意, 但是有办法可以做到这样的绑定, 以后我们会提及. 现在只要记住一点就可以了: 这些 on* 的事件监听只能用在普通的 HTML 的标签上, 而不能用在组件标签上.

** event 对象
 和普通浏览器一样, 事件监听函数会被自动传入一个 event 对象, 这个对象和普通的浏览器 event 对象所包含的方法和属性都基本一致.
 不同的是 React.js 中的 event 对象并不是浏览器提供的, 而是它自己内部所构建的.React.js 将浏览器原生的 event 对象封装了一下, 对外提供统一的 API 和属性, 这样你就不用考虑不同浏览器的兼容性问题. 这个 event 对象是符合 W3C 标准(W3C UI Events) 的, 它具有类似于 event.stopPropagation, event.preventDefault 这种常用的方法.

 我们来尝试一下, 这次尝试当用户点击 h1 的时候, 把 h1 的 innerHTML 打印出来:

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Title extends Component {
     handleClickOnTitle (e) {
         console.log(e.target.innerHTML)
     }

     render () {
         return (
             <h1 onClick={this.handleClickOnTitle}>React 小书</h1>
         )
     }
 }
 #+END_SRC

 再看看控制台, 每次点击的时候就会打印"React 小书".

** 关于事件中的 this
 一般在某个类的实例方法里面的 this 指的是这个实例本身. 但是你在上面的 handleClickOnTitle 中把 this 打印出来, 你会看到 this 是 null 或者 undefined.

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     handleClickOnTitle (e) {
         console.log(this) // => null or undefined
     }
 ...
 #+END_SRC

 这是因为 React.js 调用你所传给它的方法的时候, 并不是通过对象方法的方式调用 (this.handleClickOnTitle), 而是直接通过函数调用 (handleClickOnTitle), 所以事件监听函数内并不能通过 this 获取到实例.

 =如果你想在事件函数当中使用当前的实例, 你需要手动地将实例方法 bind 到当前实例上再传入给 React.js.=

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Title extends Component {
     handleClickOnTitle (e) {
         console.log(this)
     }

     render () {
         return (
             <h1 onClick={this.handleClickOnTitle.bind(this)}>React 小书</h1>
         )
     }
 }
 #+END_SRC

 bind 会把实例方法绑定到当前实例上, 然后我们再把绑定后的函数传给 React.js 的 onClick 事件监听. 这时候你再看看, 点击 h1 的时候, 就会把当前的实例打印出来:

 [[file:screenshotImg/07937EC0-AAFE-4FD5-ABB7-06A69EBF54C7.png]]

 你也可以在 bind 的时候给事件监听函数传入一些参数:

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Title extends Component {
     handleClickOnTitle (word, e) {
         console.log(this, word)
     }

     render () {
         return (
             <h1 onClick={this.handleClickOnTitle.bind(this, 'Hello')}>React 小书</h1>
         )
     }
 }
 #+END_SRC

 这种 bind 模式在 React.js 的事件监听当中非常常见,bind 不仅可以帮我们把事件监听方法中的 this 绑定到当前组件实例上, 还可以帮助我们在在渲染列表元素的时候, 把列表元素传入事件监听函数当中——这个将在以后的章节提及.

 如果有些同学对 JavaScript 的 this 模式或者 bind 函数的使用方式不是特别了解到话, 可能会对这部分内容会有些迷惑, 可以补充对 JavaScript 的 [[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this][this]] 和 [[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind][bind]] 相关的知识再来回顾这部分内容.

** 总结
 为 React 的组件添加事件监听是很简单的事情, 你只需要使用 React.js 提供了一系列的 on* 方法即可.

 React.js 会给每个事件监听传入一个 event 对象, 这个对象提供的功能和浏览器提供的功能一致, 而且它是兼容所有浏览器的.

 React.js 的事件监听方法需要手动 bind 到当前实例, 这种模式在 React.js 中非常常用.

** 不能摸的狗
 有一只狗, 不允许别人摸它, 一旦摸它就会叫, 然后就跑了.

 完成 Dog 组件, 当用户点击的时候会执行自身的 bark 和 run 方法.

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Dog extends Component {
     bark () {
         console.log('bark')
     }

     run () {
         console.log('run')
     }

     render () {
         return (<div onClick={()=>{this.bark();this.run();}}>DOG</div>)
     }
 }
 #+END_SRC

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Dog extends Component {
     bark () {
         console.log('bark')
     }

     run () {
         console.log('run')
     }

     handleOnClick () {
         this.bark();
         this.run();
     }

     render () {
         return (<div onClick={this.handleOnClick.bind(this)}>DOG</div>)
     }
 }
 #+END_SRC

 如果不使用 =bind(this)=, 出现如下错误:

 [[file:screenshotImg/FireShot%20Capture%20041%20-%20Hello,%20world!%20-%20http___localhost_3000_.png]]

* 组件的 state 和 setState
** state
 我们前面提到过, 一个组件的显示形态是可以由它数据状态和配置参数决定的. 一个组件可以拥有自己的状态, 就像一个点赞按钮, 可以有" 已点赞" 和" 未点赞" 状态, 并且可以在这两种状态之间进行切换.React.js 的 state 就是用来存储这种可变化的状态的.

 [[file:screenshotImg/B7575C67-64F8-4A13-9C63-4D6805FA360D.png]]

 我们还是拿点赞按钮做例子, 它具有已点赞和未点赞两种状态. 那么就可以把这个状态存储在 state 中. 修改 `src/index.js` 为:

 #+BEGIN_SRC javascript :results valuse list :exports both
 import React, { Component } from 'react'
 import ReactDOM from 'react-dom'
 import './index.css'

 class LikeButton extends Component {
     constructor () {
         super()
         this.state = { isLiked: false }
     }

     handleClickOnLikeButton () {
         this.setState({
             isLiked: !this.state.isLiked
         })
     }

     render () {
         return (
             <button onClick={this.handleClickOnLikeButton.bind(this)}>
             {this.state.isLiked ? '取消' : '点赞'} 👍
             </button>
         )
     }
 }
 ...
 #+END_SRC

 isLiked 存放在实例的 state 对象当中, 这个对象在构造函数里面初始化. 这个组件的 render 函数内, 会根据组件的 state 的中的 isLiked 不同显示" 取消" 或" 点赞" 内容. 并且给 button 加上了点击的事件监听.

 最后构建一个 Index , 在它的 render 函数内使用 LikeButton . 然后把 Index 渲染到页面上:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     class Index extends Component {
         render () {
             return (
                 <div>
                     <LikeButton />
                 </div>
             )
         }
     }

 ReactDOM.render(
     <Index />,
     document.getElementById('root')
 )
 #+END_SRC

** setState 接受对象参数
 在 handleClickOnLikeButton 事件监听函数里面, 大家可以留意到, 我们调用了 setState 函数, 每次点击都会更新 isLiked 属性为 !isLiked, 这样就可以做到点赞和取消功能.

 setState 方法由父类 Component 所提供. 当我们调用这个函数的时候,React.js 会更新组件的状态 state , 并且重新调用 render 方法, 然后再把 render 方法所渲染的最新的内容显示到页面上.

 = 注意, 当我们要改变组件的状态的时候, 不能直接用 this.state = xxx 这种方式来修改, 如果这样做 React.js 就没办法知道你修改了组件的状态, 它也就没有办法更新页面.= 所以, 一定要使用 React.js 提供的 setState 方法, = 它接受一个对象或者函数作为参数.=

 传入一个对象的时候, 这个对象表示该组件的新状态. 但你只需要传入需要更新的部分就可以了, 而不需要传入整个对象. 例如, 假设现在我们有另外一个状态 name :

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     constructor (props) {
         super(props)
         this.state = {
             name: 'Tomy',
             isLiked: false
         }
     }

 handleClickOnLikeButton () {
     this.setState({
         isLiked: !this.state.isLiked
     })
 }
 ...
 #+END_SRC

 因为点击的时候我们并不需要修改 name, 所以只需要传入 isLiked 就行了.Tomy 还是那个 Tomy, 而 isLiked 已经不是那个 isLiked 了.

** setState 接受函数参数
 这里还有要注意的是, 当你调用 setState 的时候,React.js 并不会马上修改 state.
 而是把这个对象放到一个更新队列里面, 稍后才会从队列当中把新的状态提取出来合并到 state 当中, 然后再触发组件更新. 这一点要好好注意. 可以体会一下下面的代码:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     handleClickOnLikeButton () {
         console.log(this.state.isLiked)
         this.setState({
             isLiked: !this.state.isLiked
         })
         console.log(this.state.isLiked)
     }
 ...
 #+END_SRC

 你会发现两次打印的都是 false, 即使我们中间已经 setState 过一次了.
 这并不是什么 bug, 只是 React.js 的 setState 把你的传进来的状态缓存起来, 稍后才会帮你更新到 state 上, 所以你获取到的还是原来的 isLiked.

 所以如果你想在 setState 之后使用新的 state 来做后续运算就做不到了, 例如:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     handleClickOnLikeButton () {
         this.setState({ count: 0 }) // => this.state.count 还是 undefined
         this.setState({ count: this.state.count + 1}) // => undefined + 1 = NaN
         this.setState({ count: this.state.count + 2}) // => NaN + 2 = NaN
     }
 ...
 #+END_SRC

 上面的代码的运行结果并不能达到我们的预期, 我们希望 count 运行结果是 3 , 可是最后得到的是 NaN.
 但是这种后续操作依赖前一个 setState 的结果的情况并不罕见.

 这里就自然地引出了 setState 的第二种使用方式, =可以接受一个函数作为参数.React.js 会把上一个 setState 的结果传入这个函数, 你就可以使用该结果进行运算, 操作, 然后返回一个对象作为更新 state 的对象:=

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     handleClickOnLikeButton () {
         this.setState((prevState) => {
             return { count: 0 }
         })
         this.setState((prevState) => {
             return { count: prevState.count + 1 } // 上一个 setState 的返回是 count 为 0, 当前返回 1
         })
         this.setState((prevState) => {
             return { count: prevState.count + 2 } // 上一个 setState 的返回是 count 为 1, 当前返回 3
         })
         // 最后的结果是 this.state.count 为 3
     }
 ...
 #+END_SRC

 这样就可以达到上述的利用上一次 setState 结果进行运算的效果.

** setState 合并
 上面我们进行了三次 setState, 但是实际上组件只会重新渲染一次, 而不是三次, 这是因为在 React.js 内部会把 JavaScript 事件循环中的消息队列的同一个消息中的 setState 都进行合并以后再重新渲染组件.

 深层的原理并不需要过多纠结, 你只需要记住的是: 在使用 React.js 的时候, 并不需要担心多次进行 setState 会带来性能问题.

** 不能摸的狗(二)
 有一只狗, 不允许别人摸它, 一旦摸它就会叫, 然后就跑了, 这只狗跑一段时间(20~50ms) 以后就会停下来, 也不叫了.

 完成 Dog 组件, 当用户点击的时候会执行自身的 bark 和 run 方法. 给这个 Dog 组件加上状态 isRunning 和 isBarking, 在进行相应的动作的时候设置为 true, 停下来的时候设置为 false.
 #+BEGIN_SRC javascript :results valuse list :exports both
  class Dog extends Component {
      constructor () {
          super()
          this.state = {
              isBarking: true,
              isRunning: true
          }
      }

      bark () {
          console.log("Barking")
      }

      run () {
          console.log("Running")
      }

      render () {
          setTimeout(()=>{this.setState({isBarking:false, isRunning:false})}, 10000)
          return(<div onClick={()=>{if (this.state.isBarking){this.bark()}; if (this.state.isRunning){this.run()};}}>Dog</div>)
      }

  }
  #+END_SRC

* 配置组件的 props
组件是相互独立, 可复用的单元, 一个组件可能在不同地方被用到. 但是在不同的场景下对这个组件的需求可能会根据情况有所不同, 例如一个点赞按钮组件, 在我这里需要它显示的文本是" 点赞" 和" 取消", 当别的同事拿过去用的时候, 却需要它显示" 赞" 和" 已赞".
如何让组件能适应不同场景下的需求, 我们就要让组件具有一定的" 可配置" 性.

React.js 的 props 就可以帮助我们达到这个效果. 每个组件都可以接受一个 props 参数, 它是一个对象, 包含了所有你对这个组件的配置. 就拿我们点赞按钮做例子:

[[file:screenshotImg/B7575C67-64F8-4A13-9C63-4D6805FA360D.png]]

下面的代码可以让它达到上述的可配置性:

#+BEGIN_SRC javascript :results valuse list :exports both
class LikeButton extends Component {
    constructor () {
        super()
        this.state = { isLiked: false }
    }

    handleClickOnLikeButton () {
        this.setState({
            isLiked: !this.state.isLiked
        })
    }

    render () {
        const likedText = this.props.likedText || '取消'
        const unlikedText = this.props.unlikedText || '点赞'
        return (
            <button onClick={this.handleClickOnLikeButton.bind(this)}>
                {this.state.isLiked ? likedText : unlikedText} 👍
            </button>
        )
    }
}
#+END_SRC

从 render 函数可以看出来, 组件内部是通过 this.props 的方式获取到组件的参数的, 如果 this.props 里面有需要的属性我们就采用相应的属性, 没有的话就用默认的属性.

那么怎么把 props 传进去呢? 在使用一个组件的时候, 可以把参数放在标签的属性当中, 所有的属性都会作为 props 对象的键值:

#+BEGIN_SRC javascript :results valuse list :exports both
class Index extends Component {
    render () {
        return (
            <div>
                <LikeButton likedText='已赞' unlikedText='赞' />
            </div>
        )
    }
}
#+END_SRC

就像你在用普通的 HTML 标签的属性一样, 可以把参数放在表示组件的标签上, 组件内部就可以通过 this.props 来访问到这些配置参数了.

[[file:screenshotImg/1D4C87F2-9B05-47CE-8144-1154B5CB1FC3.png]]

前面的章节我们说过,JSX 的表达式插入可以在标签属性上使用. 所以其实可以把任何类型的数据作为组件的参数, 包括字符串, 数字, 对象, 数组, 甚至是函数等等. 例如现在我们把一个对象传给点赞组件作为参数:

#+BEGIN_SRC javascript :results valuse list :exports both
class Index extends Component {
    render () {
        return (
            <div>
                <LikeButton wordings={{likedText: '已赞', unlikedText: '赞'}} />
            </div>
        )
    }
}
#+END_SRC

现在我们把 likedText 和 unlikedText 这两个参数封装到一个叫 wordings 的对象参数内, 然后传入点赞组件中. 大家看到 {{likedText: '已赞', unlikedText: '赞'}} 这样的代码的时候, 不要以为是什么新语法. 之前讨论过, =JSX 的 {} 内可以嵌入任何表达式,{{}} 就是在 {} 内部用对象字面量返回一个对象而已.=

这时候, 点赞按钮的内部就要用 this.props.wordings 来获取到到参数了:

#+BEGIN_SRC javascript :results valuse list :exports both
class LikeButton extends Component {
    constructor () {
        super()
        this.state = { isLiked: false }
    }

    handleClickOnLikeButton () {
        this.setState({
            isLiked: !this.state.isLiked
        })
    }

    render () {
        const wordings = this.props.wordings || {
            likedText: '取消',
            unlikedText: '点赞'
        }
        return (
            <button onClick={this.handleClickOnLikeButton.bind(this)}>
            {this.state.isLiked ? wordings.likedText : wordings.unlikedText} 👍
            </button>
        )
    }
}
#+END_SRC

甚至可以往组件内部传入函数作为参数:

#+BEGIN_SRC javascript :results valuse list :exports both
class Index extends Component {
    render () {
        return (
            <div>
                <LikeButton
                wordings={{likedText: '已赞', unlikedText: '赞'}}
                onClick={() => console.log('Click on like button!')} />
            </div>
        )
    }
}
#+END_SRC

这样可以通过 this.props.onClick 获取到这个传进去的函数, 修改 LikeButton 的 handleClickOnLikeButton 方法:

#+BEGIN_SRC javascript :results valuse list :exports both
...
    handleClickOnLikeButton () {
        this.setState({
            isLiked: !this.state.isLiked
        })
        if (this.props.onClick) {
            this.props.onClick()
        }
    }
...
#+END_SRC

当每次点击按钮的时候, 控制台会显示 Click on like button! .
但这个行为不是点赞组件自己实现的, 而是我们传进去的. 所以, 一个组件的行为, 显示形态都可以用 props 来控制, 就可以达到很好的可配置性.

** 默认配置 defaultProps
 上面的组件默认配置我们是通过 || 操作符来实现. 这种需要默认配置的情况在 React.js 中非常常见, 所以 React.js 也提供了一种方式 defaultProps, 可以方便的做到默认配置.

 #+BEGIN_SRC javascript :results valuse list :exports both
 class LikeButton extends Component {
     static defaultProps = {
         likedText: '取消',
         unlikedText: '点赞'
     }

     constructor () {
         super()
         this.state = { isLiked: false }
     }

     handleClickOnLikeButton () {
         this.setState({
             isLiked: !this.state.isLiked
         })
     }

     render () {
         return (
             <button onClick={this.handleClickOnLikeButton.bind(this)}>
                 {this.state.isLiked
                  ? this.props.likedText
                  : this.props.unlikedText} 👍
             </button>
         )
     }
 }
 #+END_SRC

 注意, 我们给点赞组件加上了以下的代码:

 #+BEGIN_SRC javascript :results valuse list :exports both
 static defaultProps = {
     likedText: '取消',
     unlikedText: '点赞'
 }
 #+END_SRC

 =defaultProps 作为点赞按钮组件的类属性=, 里面是对 props 中各个属性的默认配置.
 这样我们就不需要判断配置属性是否传进来了: 如果没有传进来, 会直接使用 defaultProps 中的默认属性. 所以可以看到, 在 render 函数中, 我们会直接使用 this.props 而不需要再做判断.

** props 不可变
 props 一旦传入进来就不能改变. 修改上面的例子中的 handleClickOnLikeButton:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     handleClickOnLikeButton () {
         this.props.likedText = '取消'
         this.setState({
             isLiked: !this.state.isLiked
         })
     }
 ...

 #+END_SRC
 我们尝试在用户点击按钮的时候改变 this.props.likedText, 然后你会看到控制台报错了:

 [[file:screenshotImg/F170536D-CD3B-4828-B73E-33DC883A8E99.png]]

 你不能改变一个组件被渲染的时候传进来的 props. React.js 希望一个组件在输入确定的 props 的时候, 能够输出确定的 UI 显示形态.
 如果 props 渲染过程中可以被修改, 那么就会导致这个组件显示形态和行为变得不可预测, 这样会可能会给组件使用者带来困惑.

 但这并不意味着由 props 决定的显示形态不能被修改. 组件的使用者可以主动地通过重新渲染的方式把新的 props 传入组件当中, 这样这个组件中由 props 决定的显示形态也会得到相应的改变.

 修改上面的例子的 Index 组件:

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Index extends Component {
     constructor () {
         super()
         this.state = {
             likedText: '已赞',
             unlikedText: '赞'
         }
     }

     handleClickOnChange () {
         this.setState({
             likedText: '取消',
             unlikedText: '点赞'
         })
     }

     render () {
         return (
             <div>
                 <LikeButton
                     likedText={this.state.likedText}
                     unlikedText={this.state.unlikedText} />
                 <div>
                     <button onClick={this.handleClickOnChange.bind(this)}>
                         修改 wordings
                     </button>
                 </div>
             </div>
         )
     }
 }
 #+END_SRC

 在这里, 我们把 Index 的 state 中的 likedText 和 unlikedText 传给 LikeButton.
 Index 还有另外一个按钮, 点击这个按钮会通过 setState 修改 Index 的 state 中的两个属性.

 由于 setState 会导致 Index 重新渲染, 所以 LikedButton 会接收到新的 props, 并且重新渲染, 于是它的显示形态也会得到更新.
 这就是通过重新渲染的方式来传入新的 props 从而达到修改 LikedButton 显示形态的效果.

** 总结
 为了使得组件的可定制性更强, 在使用组件的时候, 可以在标签上加属性来传入配置参数.
 组件可以在内部通过 this.props 获取到配置参数, 组件可以根据 props 的不同来确定自己的显示形态, 达到可配置的效果.
 可以通过给组件添加类属性 defaultProps 来配置默认参数.
 props 一旦传入, 你就不可以在组件内部对它进行修改. 但是你可以通过父组件主动重新渲染的方式来传入新的 props, 从而达到更新的效果.

* state vs props
我们来一个关于 state 和 props 的总结.

state 的主要作用是用于组件保存, 控制, 修改自己的可变状态.state 在组件内部初始化, 可以被组件自身修改, 而外部不能访问也不能修改.
你可以认为 state 是一个局部的, 只能被组件自身控制的数据源.state 中状态可以通过 this.setState 方法进行更新,setState 会导致组件的重新渲染.

props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件.
它是外部传进来的配置参数, 组件内部无法控制也无法修改. 除非外部组件主动传入新的 props, 否则组件的 props 永远保持不变.

state 和 props 有着千丝万缕的关系. 它们都可以决定组件的行为和显示形态.
一个组件的 state 中的数据可以通过 props 传给子组件, 一个组件可以使用外部传入的 props 来初始化自己的 state.
但是它们的职责其实非常明晰分明:state 是让组件控制自己的状态,props 是让外部对组件自己进行配置.

如果你觉得还是搞不清 state 和 props 的使用场景, 那么请记住一个简单的规则: =尽量少地用 state, 尽量多地用 props.=

没有 state 的组件叫 =无状态组件(stateless component)=, 设置了 state 的叫做 =有状态组件(stateful component)=.
因为状态会带来管理的复杂性, 我们尽量多地写无状态组件, 尽量少地写有状态的组件. 这样会降低代码维护的难度, 也会在一定程度上增强组件的可复用性. 前端应用状态管理是一个复杂的问题, 我们后续会继续讨论.

React.js 非常鼓励无状态组件, 在 0.14 版本引入了函数式组件——一种定义不能使用 state 组件, 例如一个原来这样写的组件:

#+BEGIN_SRC javascript :results valuse list :exports both
class HelloWorld extends Component {
    constructor() {
        super()
    }

    sayHi () {
        alert('Hello World')
    }

    render () {
        return (
            <div onClick={this.sayHi.bind(this)}>Hello World</div>
        )
    }
}
#+END_SRC

用函数式组件的编写方式就是:

#+BEGIN_SRC javascript :results valuse list :exports both
const HelloWorld = (props) => {
    const sayHi = (event) => alert('Hello World')
    return (
        <div onClick={sayHi}>Hello World</div>
    )
}
#+END_SRC

以前一个组件是通过继承 Component 来构建, 一个子类就是一个组件. 而用函数式的组件编写方式是一个函数就是一个组件, 你可以和以前一样通过 <HellWorld /> 使用该组件.
不同的是, = 函数式组件= 只能接受 props 而无法像跟类组件一样可以在 constructor 里面初始化 state. 你可以理解函数式组件就是一种只能接受 props 和提供 render 方法的类组件.

但本书全书不采用这种函数式的方式来编写组件, 统一通过继承 Component 来构建组件.

* 渲染列表数据
列表数据在前端非常常见, 我们经常要处理这种类型的数据, 例如文章列表, 评论列表, 用户列表…一个前端工程师几乎每天都需要跟列表数据打交道.

React.js 当然也允许我们处理列表数据, 但在使用 React.js 处理列表数据的时候, 需要掌握一些规则. 我们这一节会专门讨论这方面的知识.

** 渲染存放 JSX 元素的数组
 假设现在我们有这么一个用户列表数据, 存放在一个数组当中:

 #+BEGIN_SRC javascript :results valuse list :exports both
 const users = [
     { username: 'Jerry', age: 21, gender: 'male' },
     { username: 'Tomy', age: 22, gender: 'male' },
     { username: 'Lily', age: 19, gender: 'female' },
     { username: 'Lucy', age: 20, gender: 'female' }
 ]
 #+END_SRC

 如果现在要把这个数组里面的数据渲染页面上要怎么做? 开始之前要补充一个知识. 之前说过 JSX 的表达式插入 {} 里面可以放任何数据, 如果我们往 {} 里面放一个存放 JSX 元素的数组会怎么样?

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...

 class Index extends Component {
     render () {
         return (
             <div>
             {[
                 <span>React.js </span>,
                 <span>is </span>,
                 <span>good</span>
             ]}
             </div>
         )
     }
 }

 ReactDOM.render(
     <Index />,
     document.getElementById('root')
 )
 #+END_SRC

 我们往 JSX 里面塞了一个数组, 这个数组里面放了一些 JSX 元素(其实就是 JavaScript 对象). 到浏览器中, 你在页面上会看到:

 [[file:screenshotImg/3ADE3817-7D91-4462-830D-1802D8345326.png]]

 审查一下元素, 看看会发现什么:

 [[file:screenshotImg/05FD6746-FEF5-4253-9802-EB563643DEDC.png]]

 React.js 把插入表达式数组里面的每一个 JSX 元素一个个罗列下来, 渲染到页面上.
 所以这里有个关键点: 如果你往 {} 放一个数组,React.js 会帮你把数组里面一个个元素罗列并且渲染出来.

** 使用 map 渲染列表数据
 知道这一点以后你就可以知道怎么用循环把元素渲染到页面上: 循环上面用户数组里面的每一个用户, 为每个用户数据构建一个 JSX, 然后把 JSX 放到一个新的数组里面, 再把新的数组插入 render 方法的 JSX 里面. 看看代码怎么写:

 #+BEGIN_SRC javascript :results valuse list :exports both
 const users = [
     { username: 'Jerry', age: 21, gender: 'male' },
     { username: 'Tomy', age: 22, gender: 'male' },
     { username: 'Lily', age: 19, gender: 'female' },
     { username: 'Lucy', age: 20, gender: 'female' }
 ]

 class Index extends Component {
     render () {
         const usersElements = [] // 保存每个用户渲染以后 JSX 的数组
         for (let user of users) {
             usersElements.push( // 循环每个用户, 构建 JSX,push 到数组中
                 <div>
                     <div>姓名:{user.username}</div>
                     <div>年龄:{user.age}</div>
                     <div>性别:{user.gender}</div>
                     <hr />
                 </div>
             )
         }

         return (
             <div>{usersElements}</div>
         )
     }
 }

 ReactDOM.render(
     <Index />,
     document.getElementById('root')
 )
 #+END_SRC

 这里用了一个新的数组 usersElements, 然后循环 users 数组, 为每个 user 构建一个 JSX 结构, 然后 push 到 usersElements 中.
 然后直接用表达式插入, 把这个 userElements 插到 return 的 JSX 当中. 因为 React.js 会自动化帮我们把数组当中的 JSX 罗列渲染出来, 所以可以看到页面上显示:

 [[file:screenshotImg/AABC1755-55EA-4E42-8763-A15234DB1F02.png]]

 但我们一般不会手动写循环来构建列表的 JSX 结构, 可以直接用 ES6 自带的 map(不了解 map 函数的同学可以先了解相关的知识再来回顾这里), 代码可以简化成:

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Index extends Component {
     render () {
         return (
             <div>
             {users.map((user) => {
                 return (
                     <div>
                         <div>姓名:{user.username}</div>
                         <div>年龄:{user.age}</div>
                         <div>性别:{user.gender}</div>
                         <hr />
                     </div>
                 )
             })}
             </div>
         )
     }
 }
 #+END_SRC

 这样的模式在 JavaScript 中非常常见, 一般来说, 在 React.js 处理列表就是用 map 来处理, 渲染的. 现在进一步把渲染单独一个用户的结构抽离出来作为一个组件, 继续优化代码:

 #+BEGIN_SRC javascript :results valuse list :exports both
 const users = [
     { username: 'Jerry', age: 21, gender: 'male' },
     { username: 'Tomy', age: 22, gender: 'male' },
     { username: 'Lily', age: 19, gender: 'female' },
     { username: 'Lucy', age: 20, gender: 'female' }
 ]

 class User extends Component {
     render () {
         const { user } = this.props
         return (
             <div>
                 <div>姓名:{user.username}</div>
                 <div>年龄:{user.age}</div>
                 <div>性别:{user.gender}</div>
                 <hr />
             </div>
         )
     }
 }

 class Index extends Component {
     render () {
         return (
             <div>
                 {users.map((user) => <User user={user} />)}
             </div>
         )
     }
 }

 ReactDOM.render(
     <Index />,
     document.getElementById('root')
 )
 #+END_SRC

 这里把负责展示用户数据的 JSX 结构抽离成一个组件 User, 并且通过 props 把 user 数据作为组件的配置参数传进去, 这样改写 Index 就非常清晰了, 看一眼就知道负责渲染 users 列表, 而用的组件是 User.

** key! key! key!
 现在代码运作正常, 好像没什么问题. 打开控制台看看:

 [[file:screenshotImg/85CA5037-99C1-422C-99A4-AADA978C6801.png]]

 React.js 报错了. 如果需要详细解释这里报错的原因, 估计要单独写半本书. 但可以简单解释一下.

 React.js 的是非常高效的, 它高效依赖于所谓的 Virtual-DOM 策略. 简单来说, 能复用的话 React.js 就会尽量复用, 没有必要的话绝对不碰 DOM. 对于列表元素来说也是这样, 但是处理列表元素的复用性会有一个问题: 元素可能会在一个列表中改变位置. 例如:

 #+BEGIN_SRC html :results valuse list :exports both
 <div>a</div>
 <div>b</div>
 <div>c</div>
 #+END_SRC

 假设页面上有这么 3 个列表元素, 现在改变一下位置:

 #+BEGIN_SRC html :results valuse list :exports both
 <div>a</div>
 <div>c</div>
 <div>b</div>
 #+END_SRC

 c 和 b 的位置互换了. 但其实 React.js 只需要交换一下 DOM 位置就行了, 但是它并不知道其实我们只是改变了元素的位置, 所以它会重新渲染后面两个元素(再执行 Virtual-DOM 策略), 这样会大大增加 DOM 操作. 但如果给每个元素加上唯一的标识,React.js 就可以知道这两个元素只是交换了位置:

 #+BEGIN_SRC html :results valuse list :exports both
 <div key='a'>a</div>
 <div key='b'>b</div>
 <div key='c'>c</div>
 #+END_SRC

 这样 React.js 就简单的通过 key 来判断出来, 这两个列表元素只是交换了位置, 可以尽量复用元素内部的结构.

 这里没听懂没有关系, 后面有机会会继续讲解这部分内容.
 现在只需要记住一个简单的规则: 对于用表达式套数组罗列到页面上的元素, 都要为每个元素加上 key 属性, 这个 key 必须是每个元素唯一的标识. 一般来说,key 的值可以直接后台数据返回的 id, 因为后台的 id 都是唯一的.

 在上面的例子当中, 每个 user 没有 id 可以用, 可以直接用循环计数器 i 作为 key:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     class Index extends Component {
         render () {
             return (
                 <div>
                     {users.map((user, i) => <User key={i} user={user} />)}
                 </div>
             )
         }
     }
 ...
 #+END_SRC

 再看看, 控制台已经没有错误信息了.
 但这是不好的做法, 这只是掩耳盗铃(具体原因大家可以自己思考一下).
 记住一点: 在实际项目当中, 如果你的数据顺序可能发生变化, 标准做法是最好是后台数据返回的 id 作为列表元素的 key.

* 实战分析: 评论功能(一)
课程到这里大家已经掌握了 React.js 的基础知识和组件的基本写法了. 现在可以把我们所学到的内容应用于实战当中. 这里给大家提供一个实战的案例: 一个评论功能. 效果如下:

[[file:screenshotImg/2B86ED50-DDF5-4B3A-82A0-DECFD6767A8F.png]]

[[https://huzidaha.github.io/react-naive-book-examples/comment-app/build/index.html][在线演示地址]]

接下来会带大家一起来学习如何分析, 编写这个功能. 在这个过程中会补充一些之前没有提及的知识点, 虽然这些知识点之前没有单独拿出来讲解, 但是这些知识点也很关键.

** 组件划分
 React.js 中一切都是组件, 用 React.js 构建的功能其实也就是由各种组件组合而成. 所以拿到一个需求以后, 我们要做的第一件事情就是理解需求, 分析需求, 划分这个需求由哪些组件构成.

 组件的划分没有特别明确的标准. 划分组件的目的性是为了代码可复用性, 可维护性. 只要某个部分有可能复用到别的地方, 你都可以把它抽离出来当成一个组件, 或者把某一部分抽离出来对代码的组织和管理会带来帮助, 你也可以毫不犹豫地把它抽离出来.

 对于上面这个评论功能, 可以粗略地划分成以下几部分:

 [[file:screenshotImg/1.003.png]]

 - CommentApp: 评论功能的整体用一个叫 CommentApp 的组件包含起来.CommentApp 包含上部和下部两部分.

 - CommentInput: 上面部分是负责用户输入可操作的输入区域, 包括输入评论的用户名, 评论内容和发布按钮, 这一部分功能划分到一个单独的组件 CommentInput 中.

 - CommentList: 下面部分是评论列表, 用一个叫 CommentList 的组件负责列表的展示.

 - Comment: 每个评论列表项由独立的组件 Comment 负责显示, 这个组件被 CommentList 所使用.

 所以这个评论功能划分成四种组件,CommentApp,CommentInput,CommentList,Comment. 用组件树表示:

 [[file:screenshotImg/DAFA784B-6AD3-474B-9A87-316E5741DED6.png]]

 现在就可以尝试编写代码了.

** 组件实现
 在写代码之前, 我们先用 create-react-app 构建一个新的工程目录. 所有的评论功能在这个工程内完成:

 #+BEGIN_SRC javascript :results valuse list :exports both
 create-react-app comment-app
 #+END_SRC

 然后在工程目录下的 src/ 目录下新建四个文件, 每个文件对应的是上述的四个组件.

 #+BEGIN_SRC javascript :results valuse list :exports both
 src/
     CommentApp.js
 CommentInput.js
 CommentList.js
 Comment.js
 ...
 #+END_SRC

 你可以注意到, 这里的文件名的开头是大写字母. 我们遵循一个原则: 如果一个文件导出的是一个类, 那么这个文件名就用大写开头. 四个组件类文件导出都是类, 所以都是大写字母开头.

 我们先铺垫一些基础代码, 让组件之间的关系清晰起来. 遵循" 自顶而下, 逐步求精" 的原则, 我们从组件的顶层开始, 再一步步往下构建组件树. 先修改 CommentApp.js 如下:

 #+BEGIN_SRC javascript :results valuse list :exports both
 import React, { Component } from 'react'
 import CommentInput from './CommentInput'
 import CommentList from './CommentList'

 class CommentApp extends Component {
     render() {
         return (
             <div>
                 <CommentInput />
                 <CommentList />
             </div>
         )
     }
 }

 export default CommentApp
 #+END_SRC

 CommentApp 现在暂时还很简单, 文件顶部引入了 CommentInput 和 CommentList. 然后按照上面的需求, 应用在了 CommentApp 返回的 JSX 结构中, 上面是用户输入区域, 下面是评论列表.

 现在来修改 CommentInput.js 中的内容:

 #+BEGIN_SRC javascript :results valuse list :exports both
 import React, { Component } from 'react'

 class CommentInput extends Component {
     render() {
         return (
             <div>CommentInput</div>
         )
     }
 }

 export default CommentInput
 #+END_SRC

 这里暂时让它只简单返回 <div> 结构, 同样地修改 CommentList.js:


 #+BEGIN_SRC javascript :results valuse list :exports both
 import React, { Component } from 'react'

 class CommentList extends Component {
     render() {
         return (
             <div>CommentList</div>
         )
     }
 }

 export default CommentList
 #+END_SRC

 现在可以把这个简单的结构渲染到页面上看看什么效果, 修改 src/index.js:

 #+BEGIN_SRC javascript :results valuse list :exports both
 import React from 'react'
 import ReactDOM from 'react-dom'
 import CommentApp from './CommentApp'
 import './index.css'

 ReactDOM.render(
     <CommentApp />,
     document.getElementById('root')
 )
 #+END_SRC

 然后进入工程目录启动工程:

 #+BEGIN_SRC javascript :results valuse list :exports both
 npm run start
 #+END_SRC

 在浏览器中可以看到, 基本的结构已经渲染到了页面上了:

 [[file:screenshotImg/F1DAEB81-6DE9-4031-8476-9AA7047E4DA6.png]]

** 添加样式
 现在想让这个结构在浏览器中居中显示, 我们就要给 CommentApp 里面的 <div> 添加样式. 修改 CommentApp 中的 render 方法, 给它添加一个 wrapper 类名:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     class CommentApp extends Component {
         render() {
             return (
                 <div className='wrapper'>
                     <CommentInput />
                     <CommentList />
                 </div>
             )
         }
     }
 ...
 #+END_SRC

 后在 index.css 文件中添加样式:

 #+BEGIN_SRC css :results valuse list :exports both
 .wrapper {
     width: 500px;
     margin: 10px auto;
     font-size: 14px;
     background-color: #fff;
     border: 1px solid #f1f1f1;
     padding: 20px;
 }
 #+END_SRC

 在浏览器中可以看到样式生效了:

 [[file:screenshotImg/770AFFBC-852C-4770-965A-695B43B7BB65.png]]

 评论功能案例的所有样式都是通过这种方式进行添加. 由于我们专注点在于 React.js, 本案例后续不会在样式上过于纠缠. 这里写好了一个样式文件(index.css) 提供给大家, 可以复制到 index.css 当中. 后续只需要在元素上加上类名就可以了.

 如何在 React.js 中使用样式有很多种方式, 也是一个比较大的话题, 有很多种不同的方式也有很多不同的争论, 这个话题后续有机会会重点讲解.

* 实战分析: 评论功能(二)
上一节我们构建了基本的代码框架, 现在开始完善其他的内容.

** 处理用户输入
 我们从 ComponentInput 组件开始, 学习 React.js 是如何处理用户输入的. 首先修改 ComponentInput.js, 完善 ComponentInput 的 render 函数中的 HTML 结构:

 #+BEGIN_SRC javascript :results valuse list :exports both
 import React, { Component } from 'react'

 class CommentInput extends Component {
     render () {
         return (
             <div className='comment-input'>
                 <div className='comment-field'>
                     <span className='comment-field-name'>用户名:</span>
                     <div className='comment-field-input'>
                         <input />
                     </div>
                 </div>
                 <div className='comment-field'>
                     <span className='comment-field-name'>评论内容:</span>
                     <div className='comment-field-input'>
                         <textarea />
                     </div>
                 </div>
                 <div className='comment-field-button'>
                     <button>发布</button>
                 </div>
             </div>
         )
     }
 }

 export default CommentInput
 #+END_SRC

 在浏览器中可以看到 ComponentInput 的结构和样式都已经生效:

 [[file:screenshotImg/E384080A-1876-4C76-B2B8-940D3EB2E774.png]]

 因为还没有加入处理逻辑, 所以你输入内容, 然后点击发布是不会有什么效果的.
 用户可输入内容一个是用户名(username), 一个是评论内容(content), 我们在组件的构造函数中初始化一个 state 来保存这两个状态:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     class CommentInput extends Component {
         constructor () {
             super()
             this.state = {
                 username: '',
                 content: ''
             }
         }
         ...
     }
 ...
 #+END_SRC

 然后给输入框设置 value 属性, 让它们的 value 值等于 this.state 里面相应的值:

 #+BEGIN_SRC html :results valuse list :exports both
 ...
     <div className='comment-field'>
         <span className='comment-field-name'>用户名:</span>
         <div className='comment-field-input'>
             <input value={this.state.username} />
         </div>
     </div>
     <div className='comment-field'>
         <span className='comment-field-name'>评论内容:</span>
         <div className='comment-field-input'>
             <textarea value={this.state.content} />
         </div>
     </div>
     ...
 #+END_SRC

 可以看到接受用户名输入的 <input /> 和接受用户评论内容的 <textarea /> 的 value 值分别由 state.username 和 state.content 控制.
 这时候你到浏览器里面去输入内容看看, 你会发现你什么都输入不了.

 这是为什么呢?React.js 认为所有的状态都应该由 React.js 的 state 控制, 只要类似于 <input />,<textarea />,<select /> 这样的输入控件被设置了 value 值, 那么它们的值永远以被设置的值为准.
 值不变,value 就不会变化.

 例如, 上面设置了 <input /> 的 value 为 this.state.username,username 在 constructor 中被初始化为空字符串.
 即使用户在输入框里面尝试输入内容了, 还是没有改变 this.state.username 是空字符串的事实.

 所以应该怎么做才能把用户内容输入更新到输入框当中呢?
 在 React.js 当中必须要用 setState 才能更新组件的内容, 所以我们需要做的就是: 监听输入框的 =onChange= 事件, 然后获取到用户输入的内容, 再通过 setState 的方式更新 state 中的 username, 这样 input 的内容才会更新.

 #+CAPTION: 监听用户名输入框 1
 #+BEGIN_SRC html :results valuse list :exports both
 ...
      <div className='comment-field-input'>
        <input
          value={this.state.username}
          onChange={this.handleUsernameChange.bind(this)} />
      </div>
  ...
 #+END_SRC
 <<监听用户名输入框 1>>

 上面的代码给 input 加上了 onChange 事件监听, 绑定到 this.handleUsernameChange 方法中, 该方法实现如下:

 #+CAPTION: 监听用户名输入框 2
 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     handleUsernameChange (event) {
         this.setState({
             username: event.target.value
         })
     }
 ...
 #+END_SRC
 <<监听用户名输入框 2>>

 在这个方法中, 我们通过 event.target.value 获取 <input /> 中用户输入的内容, 然后通过 setState 把它设置到 state.username 当中, 这时候组件的内容就会更新,input 的 value 值就会得到更新并显示到输入框内. 这时候输入已经没有问题了:

 [[file:screenshotImg/10C463F1-26E4-4E05-8945-9B56D5F68CDD.png]]

 类似于 <input />,<select />,<textarea> 这些元素的 value 值被 React.js 所控制, 渲染的组件, 在 React.js 当中被称为 =受控组件(Controlled Component)=. 对于用户可输入的控件, 一般都可以让它们成为受控组件, 这是 React.js 所推崇的做法. 另外还有非受控组件, 这里暂时不提及.

 同样地, 让 <textarea /> 成为受控组件:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     handleContentChange (event) {
         this.setState({
             content: event.target.value
         })
     }
 ...
     <div className='comment-field'>
         <span className='comment-field-name'>评论内容:</span>
         <div className='comment-field-input'>
             <textarea
             value={this.state.content}
             onChange={this.handleContentChange.bind(this)} />
         </div>
     </div>
     ...
 #+END_SRC

** 向父组件传递数据
 当用户在 CommentInput 里面输入完内容以后, 点击发布, 内容其实是需要显示到 CommentList 组件当中的. 但这两个组件明显是单独的, 分离的组件. 我们再回顾一下之前是怎么划分组件的:

 [[file:screenshotImg/DAFA784B-6AD3-474B-9A87-316E5741DED6.png]]

 可以看到,CommentApp 组件将 CommentInput 和 CommentList 组合起来, 它是它们俩的父组件, 可以充当桥接两个子组件的桥梁.
 所以当用户点击发布按钮的时候, 我们就将 CommentInput 的 state 当中最新的评论数据传递给父组件 CommentApp, 然后让父组件把这个数据传递给 CommentList 进行渲染.

 CommentInput 如何向 CommentApp 传递的数据?
 父组件 CommentApp 只需要通过 props 给子组件 CommentInput 传入一个回调函数.
 当用户点击发布按钮的时候,CommentInput 调用 props 中的回调函数并且将 state 传入该函数即可.

 先给发布按钮添加事件:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     <div className='comment-field-button'>
         <button onClick={this.handleSubmit.bind(this)}>
         发布
         </button>
     </div>
     ...
 #+END_SRC

 用户点击按钮的时候会调用 this.handleSubmit 方法:

 #+CAPTION: CommentInput.handleSubmit
 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     handleSubmit () {
         if (this.props.onSubmit) {
             const { username, content } = this.state
             this.props.onSubmit({username, content})
         }
         this.setState({ content: '' })
     }
 ...
 #+END_SRC
 <<CommentInput.handleSubmit>>

 [[CommentApp.handleSubmitComment][See CommentApp.handleSubmitComment]]

 handleSubmit 方法会判断 props 中是否传入了 onSubmit 属性. 有的话就调用该函数, 并且把用户输入的用户名和评论数据传入该函数.
 然后再通过 setState 清空用户输入的评论内容(但为了用户体验, 保留输入的用户名).

 修改 CommentApp.js, 让它可以通过传入回调来获取到新增评论数据:

 #+BEGIN_SRC javascript :results valuse list :exports both
 class CommentApp extends Component {
     handleSubmitComment (comment) {
         console.log(comment)
     }

     render() {
         return (
             <div className='wrapper'>
                 <CommentInput
                 onSubmit={this.handleSubmitComment.bind(this)} />
                 <CommentList />
             </div>
         )
     }
 }
 #+END_SRC

 在 CommentApp 中给 CommentInput 传入一个 onSubmit 属性, 这个属性值是 CommentApp 自己的一个方法 handleSubmitComment. 这样 CommentInput 就可以调用 this.props.onSubmit(…) 把数据传给 CommenApp.

 现在在 CommentInput 中输入完评论内容以后点击发布, 就可以看到 CommentApp 在控制台打印的数据:

 [[file:screenshotImg/7F15DF0A-1DC8-436A-98F4-E6072DCD78BE.png]]

 这样就顺利地把数据传递给了父组件, 接下来我们开始处理评论列表相关的逻辑.

* 实战分析: 评论功能(三)
接下来的代码比较顺理成章了. 修改 CommentList 可以让它可以显示评论列表:

#+BEGIN_SRC javascript :results valuse list :exports both
// CommentList.js
import React, { Component } from 'react'

class CommentList extends Component {
    render() {
        const comments = [
            {username: 'Jerry', content: 'Hello'},
            {username: 'Tomy', content: 'World'},
            {username: 'Lucy', content: 'Good'}
        ]

        return (
            <div>{comments.map((comment, i) => {
                return (
                    <div key={i}>
                    {comment.username}:{comment.content}
                    </div>
                )
            })}
            </div>
        )
    }
}

export default CommentList
#+END_SRC

这里的代码没有什么新鲜的内容, 只不过是建立了一个 comments 的数组来存放一些测试数据的内容, 方便我们后续测试. 然后把 comments 的数据渲染到页面上, 这跟我们之前讲解的章节的内容一样——使用 map 构建一个存放 JSX 的数组. 就可以在浏览器看到效果:

[[file:screenshotImg/4EFF52CA-B573-4DBB-A313-8ADD90F65F24.png]]

修改 Comment.js 让它来负责具体每条评论内容的渲染:

#+BEGIN_SRC javascript :results valuse list :exports both
import React, { Component } from 'react'

class Comment extends Component {
    render () {
        return (
            <div className='comment'>
                <div className='comment-user'>
                    <span>{this.props.comment.username} </span>:
                </div>
                <p>{this.props.comment.content}</p>
            </div>
        )
    }
}

export default Comment
#+END_SRC

这个组件可能是我们案例里面最简单的组件了, 它只负责每条评论的具体显示. 你只需要给它的 props 中传入一个 comment 对象, 它就会把该对象中的 username 和 content 渲染到页面上.

马上把 Comment 应用到 CommentList 当中, 修改 CommentList.js 代码:

#+BEGIN_SRC javascript :results valuse list :exports both
import React, { Component } from 'react'
import Comment from './Comment'

class CommentList extends Component {
    render() {
        const comments = [
            {username: 'Jerry', content: 'Hello'},
            {username: 'Tomy', content: 'World'},
            {username: 'Lucy', content: 'Good'}
        ]

        return (
            <div>
            {comments.map((comment, i) => <Comment comment={comment} key={i} />)}
            </div>
        )
    }
}

export default CommentList
#+END_SRC

可以看到测试数据显示到了页面上:

[[file:screenshotImg/6A3B65A1-0CEA-4F98-B2E7-DC1D9B4CED83.png]]

之前我们说过 CommentList 的数据应该是由父组件 CommentApp 传进来的, 现在我们删除测试数据, 改成从 props 获取评论数据:

#+BEGIN_SRC javascript :results valuse list :exports both
import React, { Component } from 'react'
import Comment from './Comment'

class CommentList extends Component {
    render() {
        return (
            <div>
            {this.props.comments.map((comment, i) =>
                <Comment comment={comment} key={i} />
            )}
            </div>
        )
    }
}

export default CommentList
#+END_SRC

这时候可以看到浏览器报错了:

[[file:screenshotImg/2B73DDBA-0D90-473A-BC2A-DB9C8E132458.png]]

这是因为 CommentApp 使用 CommentList 的时候并没有传入 comments.
我们给 CommentList 加上 defaultProps 防止 comments 不传入的情况:

#+BEGIN_SRC javascript :results valuse list :exports both
class CommentList extends Component {
    static defaultProps = {
        comments: []
    }
...
#+END_SRC

这时候代码就不报错了. 但是 CommentInput 给 CommentApp 传递的评论数据并没有传递给 CommentList, 所以现在发表评论时没有反应的.

我们在 CommentApp 的 state 中初始化一个数组, 来保存所有的评论数据, 并且通过 props 把它传递给 CommentList. 修改 CommentApp.js:

#+BEGIN_SRC javascript :results valuse list :exports both
import React, { Component } from 'react'
import CommentInput from './CommentInput'
import CommentList from './CommentList'

class CommentApp extends Component {
    constructor () {
        super()
        this.state = {
        comments: []
        }
    }

    handleSubmitComment (comment) {
        console.log(comment)
    }

    render() {
        return (
            <div className='wrapper'>
                <CommentInput onSubmit={this.handleSubmitComment.bind(this)} />
                <CommentList comments={this.state.comments}/>
            </div>
        )
    }
}

export default CommentApp
#+END_SRC

接下来, 修改 handleSubmitComment : 每当用户发布评论的时候, 就把评论数据插入 this.state.comments 中, 然后通过 setState 把数据更新到页面上:

#+CAPTION: CommentApp.handleSubmitComment
#+BEGIN_SRC javascript :results valuse list :exports both
...
    handleSubmitComment (comment) {
        this.state.comments.push(comment)
        this.setState({
            comments: this.state.comments
        })
    }
...
#+END_SRC
<<CommentApp.handleSubmitComment>>

[[CommentInput.handleSubmit][See CommentInput.handleSubmit]]

#+BEGIN_QUOTE
小提示: 这里的代码直接往 state.comments 数组里面插入数据其实违反了 React.js 的 state 不可直接修改的原则.
但其实这个原则是为了 shouldComponentUpdate 的优化和变化的跟踪, 而这种目的在使用 React-redux 的时候其实会自然而然达到, 我们很少直接手动地优化, 这时候这个原则就会显得有点鸡肋.
所以这里为了降低大家的理解成本就不强制使用这个原则, 有兴趣的朋友可以参考: Tutorial: Intro To React - React.
#+END_QUOTE

现在代码应该是可以按照需求正常运作了, 输入用户名和评论内容, 然后点击发布:

[[file:screenshotImg/62C055E7-F668-4C70-A0C0-B8989A5E3B58.png]]

为了让代码的健壮性更强, 给 handleSubmitComment 加入简单的数据检查:

#+BEGIN_SRC javascript :results valuse list :exports both
...
    handleSubmitComment (comment) {
        if (!comment) return
        if (!comment.username) return alert('请输入用户名')
        if (!comment.content) return alert('请输入评论内容')
        this.state.comments.push(comment)
        this.setState({
            comments: this.state.comments
        })
    }
...
#+END_SRC

到这里, 我们的第一个实战案例——评论功能已经完成了! 完整的案例代码可以在这里 [[https://github.com/huzidaha/react-naive-book-examples/tree/master/comment-app/src][comment-app]] 找到, [[https://huzidaha.github.io/react-naive-book-examples/comment-app/build/index.html][在线演示]] 体验.

总结
在这个案例里面, 我们除了复习了之前所学过的内容以外还学习了新的知识点. 包括:

- 实现功能之前先理解, 分析需求, 划分组件. 并且掌握划分组件的基本原则——可复用性, 可维护性.
- 受控组件的概念,React.js 中的 <input /> ,<textarea />,<select /> 等元素的 value 值如果是受到 React.js 的控制, 那么就是受控组件.
- 组件之间使用 props 通过父元素传递数据的技巧.
当然, 在真实的项目当中, 这个案例很多地方是可以优化的.
包括组件可复用性方面(有没有发现其实 CommentInput 中有重复的代码?), 应用的状态管理方面.
但在这里为了给大家总结和演示, 实现到这个程度也就足够了.

到此为止,React.js 小书的第一阶段已经结束, 你可以利用这些知识点来构建简单的功能模块了.
但是在实际项目如果要构建比较系统和完善的功能, 还需要更多的 React.js 的知识还有关于前端开发的一些认知来协助我们. 接下来我们会开启新的一个阶段来学习更多关于 React.js 的知识, 以及如何更加灵活和熟练地使用它们. 让我们进入第二阶段吧!
