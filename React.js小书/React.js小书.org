# -*- eval: (setq org-download-image-dir (concat default-directory "/screenshotImg")); -*-
#+LATEX_CLASS: my-article
* React.js 简介
React.js 是一个帮助你构建页面 UI 的库. 如果你熟悉 MVC 概念的话, 那么 React 的组件就
相当于 MVC 里面的 View. 如果你不熟悉也没关系, 你可以简单地理解为,React.js 将帮助
我们将界面分成了各个独立的小块, 每一个块就是组件, 这些组件之间可以组合, 嵌套, 就成
了我们的页面.

一个组件的显示形态和行为有可能是由某些数据决定的. 而数据是可能发生改变的, 这时候组
件的显示形态就会发生相应的改变. 而 React.js 也提供了一种非常高效的方式帮助我们做到
了数据和组件显示形态之间的同步.

React.js 不是一个框架, 它只是一个库. 它只提供 UI(view) 层面的解决方案. 在实际的项
目当中, 它并不能解决我们所有的问题, 需要结合其它的库, 例如 Redux,React-router 等来
协助提供完整的解决方法.

* 前端组件化(一): 从一个简单的例子讲起
很多课程一上来就给大家如何配置环境, 怎么写 React.js 组件. 但是本课程还是希望大家对问题的根源有一个更加深入的了解, 其实很多的库, 框架都是解决类似的问题. 只有我们对这些库, 框架解决的问题有深入的了解和思考以后, 我们才能得心应手地使用它们, 并且有新的框架出来也不会太过迷茫————因为其实它们解决都是同一个问题.

这两节课我们来探讨一下是什么样的问题导致了我们需要前端页面进行组件化, 前端页面的组件化需要解决什么样的问题. 后续课程我们再来看看 React.js 是怎么解决这些问题的.

所以这几节所讲的内容将和 React.js 的内容没有太大的关系, 但是如果你能顺利了解这几节的内容, 那么后面那些对新手来说很复杂的概念对你来说就是非常自然的事.

** 一个简单的点赞功能
 我们会从一个简单的点赞功能讲起. 假设现在我们需要实现一个点赞, 取消点赞的功能.

 [[file:screenshotImg/B7575C67-64F8-4A13-9C63-4D6805FA360D.png][file:screenshotImg/B7575C67-64F8-4A13-9C63-4D6805FA360D.png]]

 如果你对前端稍微有一点了解, 你就顺手拈来:

 #+BEGIN_SRC html
 <body>
   <div class='wrapper'>
     <button class='like-btn'>
       <span class='like-text'>点赞</span>
       <span>👍</span>
     </button>
   </div>
 </body>
 #+END_SRC

 为了模拟现实当中的实际情况, 所以这里特意把这个 button 里面的 HTML 结构搞得稍微复杂一些. 有了这个 HTML 结构, 现在就给它加入一些 JavaScript 的行为:

 #+BEGIN_SRC javascript
 const button = document.querySelector('.like-btn')
     const buttonText = button.querySelector('.like-text')
     let isLiked = false
     button.addEventListener('click', () => {
             isLiked = !isLiked
             if (isLiked) {
                 buttonText.innerHTML = '取消'
             } else {
                 buttonText.innerHTML = '点赞'
             }
         }, false)
 #+END_SRC

 功能和实现都很简单, 按钮已经可以提供点赞和取消点赞的功能. 这时候你的同事跑过来了, 说他很喜欢你的按钮, 他也想用你写的这个点赞功能. 这时候问题就来了, 你就会发现这种实现方式很致命: 你的同事要把整个 button 和里面的结构复制过去, 还有整段 JavaScript 代码也要复制过去. 这样的实现方式没有任何可复用性.

** 结构复用
 现在我们来重新编写这个点赞功能, 让它具备一定的可复用. 这次我们先写一个类, 这个类有 render 方法, 这个方法里面直接返回一个表示 HTML 结构的字符串:

 #+BEGIN_SRC javascript
 class LikeButton {
    render () {
        return `
         <button id='like-btn'>
           <span class='like-text'>赞</span>
           <span>👍</span>
         </button>
       `
    }
 }
 #+END_SRC

 然后可以用这个类来构建不同的点赞功能的实例, 然后把它们插到页面中.

 #+BEGIN_SRC javascript
 const wrapper = document.querySelector('.wrapper')
 const likeButton1 = new LikeButton()
 wrapper.innerHTML = likeButton1.render()

 const likeButton2 = new LikeButton()
 wrapper.innerHTML += likeButton2.render()
 #+END_SRC

 这里非常暴力地使用了 innerHTML , 把两个按钮粗鲁地插入了 wrapper 当中. 虽然你可能会对这种实现方式非常不满意, 但我们还是勉强了实现了结构的复用. 我们后面再来优化它.

** 实现简单的组件化
 你一定会发现, 现在的按钮是死的, 你点击它它根本不会有什么反应. 因为根本没有往上面添加事件. 但是问题来了, LikeButton 类里面是虽然说有一个 button, 但是这玩意根本就是在字符串里面的. 你怎么能往一个字符串里面添加事件呢?DOM 事件的 API 只有 DOM 结构才能用.

 我们需要 DOM 结构, 准确地来说: 我们需要这个点赞功能的 HTML 字符串表示的 DOM 结构. 假设我们现在有一个函数 =createDOMFromString=, 你往这个函数传入 HTML 字符串, 但是它会把相应的 DOM 元素返回给你. 这个问题就可以解决了.

 #+CAPTION: createDOMFromString
 #+BEGIN_SRC javascript
 // ::String => ::Document
 const createDOMFromString = (domString) => {
     const div = document.createElement('div')
     div.innerHTML = domString
     return div
 }
 #+END_SRC
 <<createDOMFromString>>

 先不用管这个函数应该怎么实现, 先知道它是干嘛的. 拿来用就好, 这时候用它来改写一下 LikeButton 类:

 #+CAPTION: render
 #+BEGIN_SRC javascript
 class LikeButton {
     render () {
         this.el = createDOMFromString(`
         <button class='like-button'>
           <span class='like-text'>点赞</span>
           <span>👍</span>
         </button>
       `)
         this.el.addEventListener('click', () => console.log('click'), false)
         return this.el
     }
 }
 #+END_SRC
 <<render>>

 现在 render() 返回的不是一个 html 字符串了, 而是一个由这个 html 字符串所生成的 DOM. 在返回 DOM 元素之前会先给这个 DOM 元素上添加事件再返回.

 因为现在 render 返回的是 DOM 元素, 所以不能用 innerHTML 暴力地插入 wrapper. 而是要用 =DOM API= 插进去.

 #+BEGIN_SRC javascript :results valuse list
 const wrapper = document.querySelector('.wrapper')

 const likeButton1 = new LikeButton()
 wrapper.appendChild(likeButton1.render())

 const likeButton2 = new LikeButton()
 wrapper.appendChild(likeButton2.render())
 #+END_SRC

 现在你点击这两个按钮, 每个按钮都会在控制台打印 click, 说明事件绑定成功了. 但是按钮上的文本还是没有发生改变, 只要稍微改动一下 LikeButton 的代码就可以完成完整的功能:

 #+BEGIN_SRC javascript
 class LikeButton {
     constructor () {
         this.state = { isLiked: false }
     }

     changeLikeText () {
         const likeText = this.el.querySelector('.like-text')
         this.state.isLiked = !this.state.isLiked
         likeText.innerHTML = this.state.isLiked ? '取消' : '点赞'
     }

     render () {
         this.el = createDOMFromString(`
         <button class='like-button'>
           <span class='like-text'>点赞</span>
           <span>👍</span>
         </button>
       `)
         this.el.addEventListener('click', this.changeLikeText.bind(this), false)
         return this.el
     }
 }
 #+END_SRC

 这里的代码稍微长了一些, 但是还是很好理解. 只不过是在给 LikeButton 类添加了构造函数, 这个构造函数会给每一个 LikeButton 的实例添加一个对象 state,state 里面保存了每个按钮自己是否点赞的状态. 还改写了原来的事件绑定函数: 原来只打印 click, 现在点击的按钮的时候会调用 changeLikeText 方法, 这个方法会根据 this.state 的状态改变点赞按钮的文本.

 现在这个组件的可复用性已经很不错了, 你的同事们只要实例化一下然后插入到 DOM 里面去就好了.

 下一节我们继续优化这个例子, 让它更加通用.

* 前端组件化(二): 优化 DOM 操作
看看上一节我们的代码, 仔细留意一下 changeLikeText 函数, 这个函数包含了 DOM 操作, 现在看起来比较简单, 那是因为现在只有 isLiked 一个状态. 由于数据状态改变会导致需要我们去更新页面的内容, 所以假想一下, 如果你的组件依赖了很多状态, 那么你的组件基本全部都是 DOM 操作.

一个组件的显示形态由多个状态决定的情况非常常见. 代码中混杂着对 DOM 的操作其实是一种不好的实践, 手动管理数据和 DOM 之间的关系会导致代码可维护性变差, 容易出错. 所以我们的例子这里还有优化的空间: 如何尽量减少这种手动 DOM 操作?

** 状态改变 -> 构建新的 DOM 元素更新页面
 这里要提出的一种解决方案: 一旦状态发生改变, 就重新调用 render 方法, 构建一个新的 DOM 元素. 这样做的好处是什么呢? 好处就是你可以在 render 方法里面使用最新的 this.state 来构造不同 HTML 结构的字符串, 并且通过这个字符串构造不同的 DOM 元素. 页面就更新了! 听起来有点绕, 看看代码怎么写, 修改原来的代码为:

 #+BEGIN_SRC javascript
 class LikeButton {
     constructor () {
         this.state = { isLiked: false }
     }

     setState (state) {
         this.state = state
         this.el = this.render()
     }

     changeLikeText () {
         this.setState({
             isLiked: !this.state.isLiked
         })
     }

     render () {
         this.el = createDOMFromString(`
         <button class='like-btn'>
           <span class='like-text'>${this.state.isLiked ? '取消' : '点赞'}</span>
           <span>👍</span>
         </button>
       `)
         this.el.addEventListener('click', this.changeLikeText.bind(this), false)
         return this.el
     }
 }
 #+END_SRC
 [[createDOMFromString][See createDOMFromString]]

 其实只是改了几个小地方:
 render 函数里面的 HTML 字符串会根据 this.state 不同而不同(这里是用了 ES6 的模版字符串, 做这种事情很方便).
 新增一个 =setState= 函数, 这个函数接受一个对象作为参数, 它会设置实例的 state, 然后重新调用一下 render 方法.
 当用户点击按钮的时候, =changeLikeText= 会构建新的 state 对象, 这个新的 state, 传入 setState 函数当中.
 这样的结果就是, 用户每次点击, =changeLikeText= 都会调用改变组件状态然后调用 setState,setState 会调用 render,render 方法会根据 state 的不同重新构建不同的 DOM 元素.

 也就是说, 你只要调用 setState, 组件就会重新渲染. 我们顺利地消除了手动的 DOM 操作.

** 重新插入新的 DOM 元素
 上面的改进不会有什么效果, 因为你仔细看一下就会发现, 其实重新渲染的 DOM 元素并没有插入到页面当中. 所以在这个组件外面, 你需要知道这个组件发生了改变, 并且把新的 DOM 元素更新到页面当中.

 重新修改一下 =setState= 方法:

 #+CAPTION: setState
 #+BEGIN_SRC javascript
 ...
     setState (state) {
         const oldEl = this.el
         this.state = state
         this.el = this.render()
         if (this.onStateChange) this.onStateChange(oldEl, this.el)
     }
 ...
 #+END_SRC
 <<setState>>

 使用这个组件的时候:

 #+BEGIN_SRC javascript
 const likeButton = new LikeButton()
 wrapper.appendChild(likeButton.render()) // 第一次插入 DOM 元素
 likeButton.onStateChange = (oldEl, newEl) => {
     wrapper.insertBefore(newEl, oldEl) // 插入新的元素
     wrapper.removeChild(oldEl) // 删除旧的元素
 }
 #+END_SRC
 <<onStateChange>>

 这里每次 =setState= 都会调用 =onStateChange= 方法, 而这个方法是实例化以后时候被设置的, 所以你可以自定义 =onStateChange= 的行为. 这里做的事是, 每当 =setState= 中构造完新的 DOM 元素以后, 就会通过 =onStateChange= 告知外部插入新的 DOM 元素, 然后删除旧的元素, 页面就更新了.
 这里已经做到了进一步的优化了: 现在不需要再手动更新页面了.

 非一般的暴力, 因为每次 =setState= 都重新构造, 新增, 删除 DOM 元素, 会导致浏览器进行大量的重排, 严重影响性能. 不过没有关系, 这种暴力行为可以被一种叫 =Virtual-DOM= 的策略规避掉, 但这不是本文所讨论的范围.

 这个版本的点赞功能很不错, 我可以继续往上面加功能, 而且还不需要手动操作 DOM. 但是有一个不好的地方, 如果我要重新另外做一个新组件, 譬如说评论组件, 那么里面的这些 =setState= 方法要重新写一遍, 其实这些东西都可以抽出来, 变成一个通用的模式. 下一节我们把这个通用模式抽离到一个类当中.

* 前端组件化(三): 抽象出公共组件类
为了让代码更灵活, 可以写更多的组件, 我们把这种模式抽象出来, 放到一个 Component 类当中:

#+CAPTION: _renderDOM
#+BEGIN_SRC javascript
class Component {
    setState (state) {
        const oldEl = this.el
        this.state = state
        this._renderDOM()
        if (this.onStateChange) this.onStateChange(oldEl, this.el)
    }

    _renderDOM () {
        this.el = createDOMFromString(this.render())
        if (this.onClick) {
            this.el.addEventListener('click', this.onClick.bind(this), false)
        }
        return this.el
    }
}
#+END_SRC
<<_renderDOM>>
[[createDOMFromString][
See createDOMFromString]]

[[%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84 render %E6%96%B9%E6%B3%95][See 返回字符串的 render 方法]]

[[setState][See setState]]

这个是一个组件父类 Component, 所有的组件都可以继承这个父类来构建. 它定义的两个方法, 一个是我们已经很熟悉的 setState, 一个是私有方法 =_renderDOM=.
=_renderDOM= 方法会调用 this.render 来构建 DOM 元素并且监听 onClick 事件.
=所以, 组件子类继承的时候只需要实现一个返回 HTML 字符串的 render 方法就可以了.=

还有一个额外的 =mount= 的方法, 其实就是把组件的 DOM 元素插入页面, 并且在 setState 的时候更新页面:

#+CAPTION: mount
#+BEGIN_SRC javascript
const mount = (component, wrapper) => {
    wrapper.appendChild(component._renderDOM())
    component.onStateChange = (oldEl, newEl) => {
        wrapper.insertBefore(newEl, oldEl)
        wrapper.removeChild(oldEl)
    }
}
#+END_SRC
<<mount>>

[[onStateChange][See onStateChange]]

这样的话我们重新写点赞组件就会变成:

#+CAPTION: 返回字符串的 render 方法
#+BEGIN_SRC javascript
class LikeButton extends Component {
    constructor () {
        super()
        this.state = { isLiked: false }
    }

    onClick () {
        this.setState({
            isLiked: !this.state.isLiked
        })
    }

    render () {
        return `
        <button class='like-btn'>
          <span class='like-text'>${this.state.isLiked ? '取消' : '点赞'}</span>
          <span>👍</span>
        </button>
      `
    }
}

mount(new LikeButton(), wrapper)
#+END_SRC
<<返回字符串的 render 方法>>

[[_renderDOM][See _renderDOM]]

这样还不够好. 在实际开发当中, 你可能需要给组件传入一些自定义的配置数据. 例如说想配置一下点赞按钮的背景颜色, 如果我给它传入一个参数, 告诉它怎么设置自己的颜色. 那么这个按钮的定制性就更强了. 所以我们可以给组件类和它的子类都传入一个参数 props, 作为组件的配置参数. 修改 Component 的构造函数为:

#+BEGIN_SRC javascript
...
    constructor (props = {}) {
        this.props = props
    }
...
#+END_SRC

继承的时候通过 super(props) 把 props 传给父类, 这样就可以通过 this.props 获取到配置参数:

#+CAPTION: 支持读取 props 参数的 render 方法
#+BEGIN_SRC javascript
class LikeButton extends Component {
    constructor (props) {
        super(props)
        this.state = { isLiked: false }
    }

    onClick () {
        this.setState({
            isLiked: !this.state.isLiked
        })
    }

    render () {
        return `
        <button class='like-btn' style="background-color: ${this.props.bgColor}">
          <span class='like-text'>
            ${this.state.isLiked ? '取消' : '点赞'}
          </span>
          <span>👍</span>
        </button>
      `
    }
}

mount(new LikeButton({ bgColor: 'red' }), wrapper)
#+END_SRC
<<支持读取 props 参数的 render 方法>>

这里我们稍微修改了一下原有的 LikeButton 的 =render= 方法, 让它可以根据传入的参数 =this.props.bgColor= 来生成不同的 style 属性. 这样就可以自由配置组件的颜色了.

只要有了上面那个 =Component= 类和 =mount= [[mount][See mount ]] 方法加起来不足 40 行代码就可以做到组件化. 如果我们需要写另外一个组件, 只需要像上面那样, 简单地继承一下 Component 类就好了:

#+BEGIN_SRC javascript
class RedBlueButton extends Component {
    constructor (props) {
        super(props)
        this.state = {
            color: 'red'
        }
    }

    onClick () {
        this.setState({
            color: 'blue'
        })
    }

    render () {
        return `
        <div style='color: ${this.state.color};'>${this.state.color}</div>
      `
    }
}
#+END_SRC

简单好用, 现在可以灵活地组件化页面了.Component 完整的代码可以在这里找到.

#+CAPTION: reactjs-in-40
#+BEGIN_SRC javascript
<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <title>Reactjs in 40 </title>
    <style media="screen">
      .like-btn { font-size: 50px; }
    </style>
  </head>

  <body>
    <div class='wrapper'></div>
  </body>

  <script type="text/javascript">
    /* Component */
    class Component {
      constructor (props = {}) {
        this.props = props
      }
      setState (state) {
        const oldEl = this.el
        this.state = state
        this.el = this.renderDOM()
        if (this.onStateChange) this.onStateChange(oldEl, this.el)
      }
      renderDOM () {
        this.el = createDOMFromString(this.render())
        if (this.onClick) {
          this.el.addEventListener('click', this.onClick.bind(this), false)
        }
        return this.el
      }
    }
    const createDOMFromString = (domString) => {
      const div = document.createElement('div')
      div.innerHTML = domString
      return div
    }
    const mount = (component, wrapper) => {
      wrapper.appendChild(component.renderDOM())
      component.onStateChange = (oldEl, newEl) => {
        wrapper.insertBefore(newEl, oldEl)
        wrapper.removeChild(oldEl)
      }
    }
    /* ========================================= */
    class LikeButton extends Component {
      constructor (props) {
        super(props)
        this.state = { isLiked: false }
      }
      onClick () {
        this.setState({
          isLiked: !this.state.isLiked
        })
      }
      render () {
        return `
          <button class='like-btn' style="background-color: ${this.props.bgColor}">
            <span class='like-text'>
              ${this.state.isLiked ? '取消' : '点赞'}
            </span>
            <span>👍</span>
          </button>
        `
      }
    }
    class RedBlueButton extends Component {
      constructor (props) {
        super(props)
        this.state = {
          color: 'red'
        }
      }
      onClick () {
        this.setState({
          color: 'blue'
        })
      }
      render () {
        return `
          <div style='color: ${this.state.color};'>${this.state.color}</div>
        `
      }
    }
    const wrapper = document.querySelector('.wrapper')
    mount(new LikeButton({ bgColor: 'red' }), wrapper)
    mount(new LikeButton(), wrapper)
    mount(new RedBlueButton(), wrapper)
  </script>
</html>
#+END_SRC
<<reactjs-in-40>>

** 总结
 我们用了很长的篇幅来讲一个简单的点赞的例子, 并且在这个过程里面一直在优化编写的方式. 最后抽离出来了一个类, 可以帮助我们更好的做组件化. 在这个过程里面我们学到了什么?

 组件化可以帮助我们解决前端结构的复用性问题, 整个页面可以由这样的不同的组件组合, 嵌套构成.

 一个组件有自己的显示形态(上面的 HTML 结构和内容) 行为, 组件的显示形态和行为可以由数据状态(state) 和配置参数(props) 共同决定. 数据状态和配置参数的改变都会影响到这个组件的显示形态.

 当数据变化的时候, 组件的显示需要更新. 所以如果组件化的模式能提供一种高效的方式自动化地帮助我们更新页面, 那也就可以大大地降低我们代码的复杂度, 带来更好的可维护性.

 好了, 课程结束了. 你已经学会了怎么使用 React.js 了, 因为我们已经写了一个——当然我是在开玩笑, 但是上面这个 Component 类其实和 React 的 Component 使用方式很类似. 掌握了这几节的课程, 你基本就掌握了基础的 React.js 的概念.

 接下来我们开始正式进入主题, 开始正式介绍 React.js. 你会发现, 有了前面的铺垫, 下面讲的内容理解起来会简单很多了.
* React.js 基本环境安装
** 安装 React.js
 React.js 单独使用基本上是不可能的事情. 不要指望着类似于 jQuery 下载放到 <head/> 标签就开始使用. 使用 React.js 不管在开发阶段生产阶段都需要一堆工具和库辅助, 编译阶段你需要借助 Babel, 需要 Redux 等第三方的状态管理工具来组织代码, 如果你要写单页面应用那么你需要 React-router. 这就是所谓的"React.js 全家桶".

 本课程不会教大家如何配置这些东西, 因为这不是课程的重点, 网上有很多的资料, 大家可以去参考那些资料. 我们这里会直接使用 React.js 官网所推荐使用的工具 create-react-app 工具. 它可以帮助我们一键生成所需要的工程目录, 并帮我们做好各种配置和依赖, 也帮我们隐藏了这些配置的细节. 也就是所谓的" 开箱即用".

 工具地址:https://github.com/facebookincubator/create-react-app

 [[file:screenshotImg/C9754D1A-0989-49B2-AC9F-B8D9717198CB.png]]

 在安装之前要确认你的机器上安装了 node.js 环境包括 npm. 如果没有安装的同学可以到 node.js 的官网下载自己电脑的对应的安装包来安装好环境.

 安装好环境以后, 只需要按照官网的指引安装 create-react-app 即可.


 #+BEGIN_SRC javascript :results valuse list :exports both
 npm install -g create-react-app
 #+END_SRC

 这条命令会往我们的机器上安装一条叫 =create-react-app= 的命令, 安装好以后就可以直接使用它来构建一个 react 的前端工程:

 #+BEGIN_SRC javascript :results valuse list :exports both
 create-react-app hello-react
 #+END_SRC

 这条命令会帮我们构建一个叫 hello-react 的工程, 并且会自动地帮助我们安装所需要的依赖, 现在只需要安静地等待它安装完.

 #+BEGIN_QUOTE
 额外的小贴士:

 如果有些同学安装过程比较慢, 那是很有可能是因为 npm 下载的时候是从国外的源下载的缘故. 所以可以把 npm 的源改成国内的 taobao 的源, 这样会加速下载过程. 在执行上面的命令之前可以先修改一下 npm 的源:

 #+BEGIN_SRC javascript :results valuse list :exports both
 npm config set registry https://registry.npm.taobao.org
 #+END_SRC

 #+END_QUOTE

 下载完以后我们就可以启动工程了, 进入工程目录然后通过 npm 启动工程:

 #+BEGIN_SRC javascript :results valuse list :exports both
 cd hello-react
 npm start
 #+END_SRC

 终端提示成功:

 [[file:screenshotImg/C9754D1A-0989-49B2-AC9F-B8D9717198CB.png]]

 并且会自动打开浏览器, 就可以看到 React 的工程顺利运行的效果:

 [[file:screenshotImg/React_App.png]]

 这时候我们把 src/App.js 文件中的 <h2> 标签的内容修改为 Hello React,

 #+BEGIN_SRC javascript :results valuse list :exports both
     <h2>Hello React</h2>
 #+END_SRC

 保存一下, 然后户就会发现浏览器自动刷新, 并且我们的修改也生效了:

 [[file:screenshotImg/3FDC1B75-AACD-40A4-9101-1AF8C57EFBF4.png]]

 到这里我们的环境已经安装好了, 并且顺利地运行了我们第一个例子. 接下来我们会探讨 React.js 的组件的基本写法.
* 使用 JSX 描述 UI 信息
这一节我们通过一个简单的例子讲解 React.js 描述页面 UI 的方式. 把 src/index.js 中的代码改成:
#+BEGIN_SRC javascript :results valuse list :exports both
import React, { Component } from 'react'
import ReactDOM from 'react-dom'
import './index.css'

class Header extends Component {
   render () {
       return (
               <div>
                 <h1>React 小书</h1>
               </div>
       )
   }
}

ReactDOM.render(
   <Header />,
   document.getElementById('root')
)
#+END_SRC

我们在文件头部从 react 的包当中引入了 React 和 React.js 的组件父类 Component. 记住, 只要你要写 React.js 组件, 那么就必须要引入这两个东西.

ReactDOM 可以帮助我们把 React 组件渲染到页面上去, 没有其它的作用了. 你可以发现它是从 react-dom 中引入的, 而不是从 react 引入. 有些朋友可能会疑惑, 为什么不把这些东西都包含在 react 包当中呢? 我们稍后会回答这个问题.

接下来的代码你看起来会比较熟悉, 但又会有点陌生. 你看其实它跟我们前几节里面讲的内容其实很类似, 一个组件继承 Component 类, 有一个 render 方法, 并且把这个组件的 HTML 结构返回, 这里 return 的东西就比较奇怪了, 它并不是一个字符串, 看起来像是纯 HTML 代码写在 JavaScript 代码里面. 你也许会说, 这不就有语法错误了么? 这完全不是合法的 JavaScript 代码. 这种看起来" 在 JavaScript 写的标签的" 语法叫 JSX.

** JSX 原理
 为了让大家深刻理解 JSX 的含义. 有必要简单介绍了一下 JSX 稍微底层的运作原理, 这样大家可以更加深刻理解 JSX 到底是什么东西, 为什么要有这种语法, 它是经过怎么样的转化变成页面的元素的.

 思考一个问题: 如何用 JavaScript 对象来表现一个 DOM 元素的结构, 举个例子:

 #+BEGIN_SRC javascript :results valuse list :exports both
 <div class='box' id='content'>
 <div class='title'>Hello</div>
 <button>Click</button>
 </div>
 #+END_SRC

 每个 DOM 元素的结构都可以用 JavaScript 的对象来表示. 你会发现一个 DOM 元素包含的信息其实只有三个: 标签名, 属性, 子元素.

 所以其实上面这个 HTML 所有的信息我们都可以用合法的 JavaScript 对象来表示:

 #+BEGIN_SRC javascript :results valuse list :exports both
 {
     tag: 'div',
     attrs: { className: 'box', id: 'content'},
     children: [
         {
             tag: 'div',
             arrts: { className: 'title' },
             children: ['Hello']
         },
         {
             tag: 'button',
             attrs: null,
             children: ['Click']
         }
     ]
 }
 #+END_SRC

 你会发现,HTML 的信息和 JavaScript 所包含的结构和信息其实是一样的, 我们可以用 JavaScript 对象来描述所有能用 HTML 表示的 UI 信息. 但是用 JavaScript 写起来太长了, 结构看起来又不清晰, 用 HTML 的方式写起来就方便很多了.

 于是 React.js 就把 JavaScript 的语法扩展了一下, 让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法, 这样写起来就方便很多了. 编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构.

 上面的代码:

 #+BEGIN_SRC javascript :results valuse list :exports both
 import React, { Component } from 'react'
 import ReactDOM from 'react-dom'
 import './index.css'

 class Header extends Component {
     render () {
         return (
                 <div>
                 <h1 className='title'>React 小书</h1>
                 </div>
         )
     }
 }

 ReactDOM.render(
     <Header />,
     document.getElementById('root')
 )
 #+END_SRC

 经过编译以后会变成:

 #+BEGIN_SRC javascript :results valuse list :exports both
 import React, { Component } from 'react'
 import ReactDOM from 'react-dom'
 import './index.css'

 class Header extends Component {
     render () {
         return (
             React.createElement(
                 "div",
                 null,
                 React.createElement(
                     "h1",
                     { className: 'title' },
                     "React 小书"
                 )
             )
         )
     }
 }

 ReactDOM.render(
     React.createElement(Header, null),
     document.getElementById('root')
 );
 #+END_SRC

 React.createElement 会构建一个 JavaScript 对象来描述你 HTML 结构的信息, 包括标签名, 属性, 还有子元素等. 这样的代码就是合法的 JavaScript 代码了. 所以使用 React 和 JSX 的时候一定要经过编译的过程.

 这里再重复一遍: 所谓的 JSX 其实就是 JavaScript 对象. 每当在 JavaScript 代码中看到这种 JSX 结构的时候, 脑子里面就可以自动做转化, 这样对你理解 React.js 的组件写法很有好处.

 有了这个表示 HTML 结构和信息的对象以后, 就可以拿去构造真正的 DOM 元素, 然后把这个 DOM 元素塞到页面上. 这也是我们最后一段代码中 ReactDOM.render 所干的事情:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ReactDOM.render(
         <Header />,
     document.getElementById('root')
 )
 #+END_SRC

 ReactDOM.render 功能就是把组件渲染并且构造 DOM 树, 然后插入到页面上某个特定的元素上(在这里是 id 为 root 的 div 元素).

 所以可以总结一下从 JSX 到页面到底经过了什么样的过程:

 [[file:screenshotImg/44B5EC06-EAEB-4BA2-B3DC-325703E4BA45.png]]

 有些同学可能会问, 为什么不直接从 JSX 直接渲染构造 DOM 结构, 而是要经过中间这么一层呢?

 第一个原因是, 当我们拿到一个表示 UI 的结构和信息的对象以后, 不一定会把元素渲染到浏览器的普通页面上, 我们有可能把这个结构渲染到 canvas 上, 或者是手机 App 上. 所以这也是为什么会要把 react-dom 单独抽离出来的原因, 可以想象有一个叫 react-canvas 可以帮我们把 UI 渲染到 canvas 上, 或者是有一个叫 react-app 可以帮我们把它转换成原生的 App(实际上这玩意叫 ReactNative).

 第二个原因是, 有了这样一个对象. 当数据变化, 需要更新组件的时候, 就可以用比较快的算法操作这个 JavaScript 对象, 而不用直接操作页面上的 DOM, 这样可以尽量少的减少浏览器重排, 极大地优化性能. 这个在以后的章节中我们会提到.

** 总结
 要记住几个点:
 - JSX 是 JavaScript 语言的一种语法扩展, 长得像 HTML, 但并不是 HTML.
 - React.js 可以用 JSX 来描述你的组件长什么样的.
 - JSX 在编译的时候会变成相应的 JavaScript 对象描述.
 - react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素, 并且渲染到页面上.

* 组件的 render 方法
React.js 中一切皆组件, 用 React.js 写的其实就是 React.js 组件. 我们在编写 React.js 组件的时候, 一般都需要继承 React.js 的 Component(还有别的编写组件的方式我们后续会提到).
一个组件类必须要实现一个 =render= 方法, 这个 render 方法必须要返回一个 JSX 元素.
但这里要注意的是, 必须要用一个外层的 JSX 元素把所有内容包裹起来. 返回并列多个 JSX 元素是不合法的, 下面是错误的做法:

#+BEGIN_SRC javascript :results valuse list :exports both
...
    render () {
        return (
                <div>第一个</div>
                <div>第二个</div>
        )
    }
...
#+END_SRC

必须要用一个外层元素把内容进行包裹:

#+BEGIN_SRC javascript :results valuse list :exports both
...
    render () {
        return (
                <div>
                <div>第一个</div>
                <div>第二个</div>
                </div>
        )
    }
...
#+END_SRC

** 表达式插入
 在 JSX 当中你可以插入 JavaScript 的表达式, 表达式返回的结果会相应地渲染到页面上. 表达式用 {} 包裹. 例如:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const word = 'is good'
         return (
               <div>
                 <h1>React 小书 {word}</h1>
               </div>
       )
     }
 ...
 #+END_SRC

 页面上就显示"React 小书 is good". 你也可以把它改成 ={1 + 2}=, 它就会显示 "React 小书 3". 你也可以把它写成一个函数表达式返回:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         return (
                 <div>
                   <h1>React 小书 {(function () { return 'is good'})()}</h1>
                 </div>
         )
     }
 ...
 #+END_SRC

 简而言之,{} 内可以放任何 JavaScript 的代码, 包括变量, 表达式计算, 函数执行等等. =render= 会把这些代码返回的内容如实地渲染到页面上, 非常的灵活.

 =表达式插入不仅仅可以用在标签内部, 也可以用在标签的属性上,= 例如:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const className = 'header'
         return (
                 <div className={className}>
                   <h1>React 小书</h1>
                 </div>
         )
     }
 ...
 #+END_SRC

 这样就可以为 div 标签添加一个叫 header 的类名.

 注意, 直接使用 class 在 React.js 的元素上添加类名如 <div class="xxx"> 这种方式是不合法的. 因为 class 是 JavaScript 的关键字, 所以 React.js 中定义了一种新的方式: =className= 来帮助我们给元素添加类名.

 还有一个特例就是 for 属性, 例如 <label for='male'>Male</label>, 因为 for 也是 JavaScript 的关键字, 所以在 JSX 用 =htmlFor= 替代, 即 <label htmlFor='male'>Male</label>. 而其他的 HTML 属性例如 style ,data-* 等就可以像普通的 HTML 属性那样直接添加上去.

 条件返回
 {} 上面说了,JSX 可以放置任何表达式内容. 所以也可以放 JSX, 实际上, 我们可以在 render 函数内部根据不同条件返回不同的 JSX. 例如:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const isGoodWord = true
         return (
                 <div>
                   <h1>
                     React 小书
                     {isGoodWord
                      ? <strong> is good</strong>
                      : <span> is not good</span>
                     }
                 </h1>
                 </div>
         )
     }
 ...
 #+END_SRC

 上面的代码中定义了一个 isGoodWord 变量为 true, 下面有个用 {} 包含的表达式, 根据 isGoodWord 的不同返回不同的 JSX 内容. 现在页面上是显示 React 小书 is good. 如果你把 isGoodWord 改成 false 然后再看页面上就会显示 React 小书 is not good.

 如果你在表达式插入里面返回 null , 那么 React.js 会什么都不显示, 相当于忽略了该表达式插入. 结合条件返回的话, 我们就做到显示或者隐藏某些元素:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const isGoodWord = true
         return (
                 <div>
                   <h1>
                     React 小书
                     {isGoodWord
                      ? <strong> is good</strong>
                      : null
                     }
                   </h1>
                 </div>
         )
     }
 ...
 #+END_SRC

 这样就相当于在 isGoodWord 为 true 的时候显示 <strong>is good</strong>, 否则就隐藏.

 条件返回 JSX 的方式在 React.js 中很常见, 组件的呈现方式随着数据的变化而不一样, 你可以利用 JSX 这种灵活的方式随时组合构建不同的页面结构.

 如果这里有些同学觉得比较难理解的话, 可以回想一下, 其实 JSX 就是 JavaScript 里面的对象, 转换一下角度, 把上面的内容翻译成 JavaScript 对象的形式, 上面的代码就很好理解了.

** JSX 元素变量
 同样的, 如果你能理解 JSX 元素就是 JavaScript 对象. 那么你就可以联想到, =JSX 元素其实可以像 JavaScript 对象那样自由地赋值给变量, 或者作为函数参数传递, 或者作为函数的返回值.=

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     render () {
         const isGoodWord = true
         const goodWord = <strong> is good</strong>
         const badWord = <span> is not good</span>
           return (
                   <div>
                     <h1>
                       React 小书
                       {isGoodWord ? goodWord : badWord}
                       </h1>
                   </div>
           )
 }
 ...
 #+END_SRC

 这里给把两个 JSX 元素赋值给了 goodWord 和 badWord 两个变量, 然后把它们作为表达式插入的条件返回值. 达到效果和上面的例子一样, 随机返回不同的页面效果呈现.

 再举一个例子:

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     renderGoodWord (goodWord, badWord) {
         const isGoodWord = true
         return isGoodWord ? goodWord : badWord
     }

 render () {
     return (
             <div>
               <h1>
                 React 小书
                 {this.renderGoodWord(
                         <strong> is good</strong>,
                         <span> is not good</span>
                 )}
               </h1>
               </div>
     )
 }
 ...
 #+END_SRC

这里我们定义了一个 renderGoodWord 函数, 这个函数接受两个 JSX 元素作为参数, 并且随机返回其中一个.
在 render 方法中, 我们把上面例子的两个 JSX 元素传入 renderGoodWord 当中, 通过表达式插入把该函数返回的 JSX 元素插入到页面上.
用 React.js 构建未读消息组件
** 使用 React.js 构建一个未读消息组件 Notification.
 通过 getNotificationsCount() 来获取未读消息的数量 , 如果有未读消息 N 条, 而且 N > 0, 那么 Notification 组件渲染显示:
 #+BEGIN_QUOTE
 <span>有(N) 条未读消息</span>
 #+END_QUOTE
 否则显示:
 #+BEGIN_QUOTE
 <span>没有未读消息</span>
 #+END_QUOTE

 #+BEGIN_SRC javascript :results valuse list :exports both
 // 函数 getNotificationsCount 已经可以直接调用

 class Notification extends Component {
     render () {
         const N = getNotificationsCount()
         return(
                 <div>
                     {N>0?<span>有({N}) 条未读消息</span>:<span>没有未读消息</span>}
                 </div>
         )
     }
 }
 #+END_SRC

 或者

 #+BEGIN_SRC javascript :results valuse list :exports both
 // 函数 getNotificationsCount 已经可以直接调用

 class Notification extends Component {
     render () {
         // TODO
         let N = getNotificationsCount()
         return (
                 <div>
                     <span>{N>0?`有(${N}) 条未读消息`:`没有未读消息`}</span>
                 </div>
         )
     }
 }
 #+END_SRC
* 组件的组合, 嵌套和组件树
继续拓展前面的例子, 现在我们已经有了 Header 组件了. 假设我们现在构建一个新的组件叫 Title, 它专门负责显示标题. 你可以在 Header 里面使用 Title 组件:

#+BEGIN_SRC javascript :results valuse list :exports both
class Title extends Component {
    render () {
        return (
                <h1>React 小书</h1>
        )
    }
}

class Header extends Component {
    render () {
        return (
                <div>
                <Title />
                </div>
        )
    }
}
#+END_SRC

我们可以直接在 Header 标签里面直接使用 Title 标签. 就像是一个普通的标签一样.React.js 会在 <Title /> 所在的地方把 Title 组件的 render 方法表示的 JSX 内容渲染出来, 也就是说 <h1>React 小书</h1> 会显示在相应的位置上.
如果现在我们在 Header 里面使用三个 <Title /> , 那么就会有三个 <h1 /> 显示在页面上.

#+BEGIN_SRC javascript :results valuse list :exports both
<div>
<Title />
<Title />
<Title />
</div>
#+END_SRC

这样可复用性非常强, 我们可以把组件的内容封装好, 然后灵活在使用在任何组件内. 另外这里要注意的是, =自定义的组件都必须要用大写字母开头=, 普通的 HTML 标签都用小写字母开头.

现在让组件多起来. 我们来构建额外的组件来构建页面, 假设页面是由 Header,Main,Footer 几个部分组成, 由一个 Index 把它们组合起来.

#+BEGIN_SRC javascript :results valuse list :exports both
import React, { Component } from 'react';
import ReactDOM from 'react-dom';

class Title extends Component {
    render () {
        return (
                <h1>React 小书</h1>
        )
    }
}

class Header extends Component {
    render () {
        return (
                <div>
                    <Title />
                    <h2>This is Header</h2>
                </div>
        )
    }
}

class Main extends Component {
    render () {
        return (
                <div>
                    <h2>This is main content</h2>
                </div>
        )
    }
}

class Footer extends Component {
    render () {
        return (
                <div>
                    <h2>This is footer</h2>
                </div>
        )
    }
}

class Index extends Component {
    render () {
        return (
                <div>
                    <Header />
                    <Main />
                    <Footer />
                </div>
        )
    }
}

ReactDOM.render
      <Index />,
      document.getElementById('root')
)
#+END_SRC

最后页面会显示内容:

[[file:screenshotImg/D57824A9-3F1F-44ED-9CFF-478902261653.png]]

组件可以和组件组合在一起, 组件内部可以使用别的组件.
就像普通的 HTML 标签一样使用就可以.
这样的组合嵌套, 最后构成一个所谓的组件树, 就正如上面的例子那样,Index 用了 Header,Main,Footer,Header 又使用了 Title.
这样用这样的树状结构表示它们之间的关系:

[[file:screenshotImg/19BBE4E2-A12E-4657-BA6A-61484F67FA60.png]]

这里的结构还是比较简单, 因为我们的页面结构并不复杂.
当页面结构复杂起来, 有许多不同的组件嵌套组合的话, 组件树会相当的复杂和庞大.
理解组件树的概念对后面理解数据是如何在组件树内自上往下流动过程很重要.
* 事件监听
在 React.js 里面监听事件是很容易的事情, 你只需要给需要监听事件的元素加上属性类似于 onClick,onKeyDown 这样的属性, 例如我们现在要给 Title 加上点击的事件监听:

#+BEGIN_SRC javascript :results valuse list :exports both
class Title extends Component {
    handleClickOnTitle () {
        console.log('Click on title.')
    }

    render () {
        return (
                <h1 onClick={this.handleClickOnTitle}>React 小书</h1>
        )
    }
}
#+END_SRC

只需要给 h1 标签加上 onClick 的事件, =onClick 紧跟着是一个表达式插入, 这个表达式返回一个 Title 自己的一个实例方法.= 当用户点击 h1 的时候,React.js 就会调用这个方法, 所以你在控制台就可以看到 Click on title. 打印出来.

在 React.js 不需要手动调用浏览器原生的 addEventListener 进行事件监听.React.js 帮我们封装好了一系列的 on* 的属性, 当你需要为某个元素监听某个事件的时候, 只需要简单地给它加上 on* 就可以了. 而且你不需要考虑不同浏览器兼容性的问题,React.js 都帮我们封装好这些细节了.

React.js 封装了不同类型的事件, 这里就不一一列举, 有兴趣的同学可以参考官网文档:[[https://reactjs.org/docs/events.html#supported-events][SyntheticEvent - React]], 多尝试不同的事件. 另外要注意的是, 这些事件属性名都必须要用驼峰命名法.

=没有经过特殊处理的话, 这些 on* 的事件监听只能用在普通的 HTML 的标签上, 而不能用在组件标签上. 也就是说,<Header onClick={…} /> 这样的写法不会有什么效果的.= 这一点要注意, 但是有办法可以做到这样的绑定, 以后我们会提及. 现在只要记住一点就可以了: 这些 on* 的事件监听只能用在普通的 HTML 的标签上, 而不能用在组件标签上.

** event 对象
 和普通浏览器一样, 事件监听函数会被自动传入一个 event 对象, 这个对象和普通的浏览器 event 对象所包含的方法和属性都基本一致. 不同的是 React.js 中的 event 对象并不是浏览器提供的, 而是它自己内部所构建的.React.js 将浏览器原生的 event 对象封装了一下, 对外提供统一的 API 和属性, 这样你就不用考虑不同浏览器的兼容性问题. 这个 event 对象是符合 W3C 标准(W3C UI Events) 的, 它具有类似于 event.stopPropagation, event.preventDefault 这种常用的方法.

 我们来尝试一下, 这次尝试当用户点击 h1 的时候, 把 h1 的 innerHTML 打印出来:

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Title extends Component {
     handleClickOnTitle (e) {
         console.log(e.target.innerHTML)
     }

     render () {
         return (
                 <h1 onClick={this.handleClickOnTitle}>React 小书</h1>
         )
     }
 }
 #+END_SRC

 再看看控制台, 每次点击的时候就会打印"React 小书".

** 关于事件中的 this
 一般在某个类的实例方法里面的 this 指的是这个实例本身. 但是你在上面的 handleClickOnTitle 中把 this 打印出来, 你会看到 this 是 null 或者 undefined.

 #+BEGIN_SRC javascript :results valuse list :exports both
 ...
     handleClickOnTitle (e) {
         console.log(this) // => null or undefined
     }
 ...
 #+END_SRC

 这是因为 React.js 调用你所传给它的方法的时候, 并不是通过对象方法的方式调用 (this.handleClickOnTitle), 而是直接通过函数调用 (handleClickOnTitle), 所以事件监听函数内并不能通过 this 获取到实例.

 =如果你想在事件函数当中使用当前的实例, 你需要手动地将实例方法 bind 到当前实例上再传入给 React.js.=


 #+BEGIN_SRC javascript :results valuse list :exports both
 class Title extends Component {
     handleClickOnTitle (e) {
         console.log(this)
     }

     render () {
         return (
                 <h1 onClick={this.handleClickOnTitle.bind(this)}>React 小书</h1>
         )
     }
 }
 #+END_SRC

 bind 会把实例方法绑定到当前实例上, 然后我们再把绑定后的函数传给 React.js 的 onClick 事件监听. 这时候你再看看, 点击 h1 的时候, 就会把当前的实例打印出来:

 [[file:screenshotImg/07937EC0-AAFE-4FD5-ABB7-06A69EBF54C7.png]]

 你也可以在 bind 的时候给事件监听函数传入一些参数:


 #+BEGIN_SRC javascript :results valuse list :exports both
 class Title extends Component {
     handleClickOnTitle (word, e) {
         console.log(this, word)
     }

     render () {
         return (
                 <h1 onClick={this.handleClickOnTitle.bind(this, 'Hello')}>React 小书</h1>
         )
     }
 }
 #+END_SRC

 这种 bind 模式在 React.js 的事件监听当中非常常见,bind 不仅可以帮我们把事件监听方法中的 this 绑定到当前组件实例上, 还可以帮助我们在在渲染列表元素的时候, 把列表元素传入事件监听函数当中——这个将在以后的章节提及.

 如果有些同学对 JavaScript 的 this 模式或者 bind 函数的使用方式不是特别了解到话, 可能会对这部分内容会有些迷惑, 可以补充对 JavaScript 的 [[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this][this]] 和 [[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind][bind]] 相关的知识再来回顾这部分内容.

** 总结
 为 React 的组件添加事件监听是很简单的事情, 你只需要使用 React.js 提供了一系列的 on* 方法即可.

 React.js 会给每个事件监听传入一个 event 对象, 这个对象提供的功能和浏览器提供的功能一致, 而且它是兼容所有浏览器的.

 React.js 的事件监听方法需要手动 bind 到当前实例, 这种模式在 React.js 中非常常用.

** 不能摸的狗
 有一只狗, 不允许别人摸它, 一旦摸它就会叫, 然后就跑了.

 完成 Dog 组件, 当用户点击的时候会执行自身的 bark 和 run 方法.

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Dog extends Component {
     bark () {
         console.log('bark')
     }

     run () {
         console.log('run')
     }

     render () {
         return (<div onClick={()=>{this.bark();this.run();}}>DOG</div>)
     }
 }
 #+END_SRC

 #+BEGIN_SRC javascript :results valuse list :exports both
 class Dog extends Component {
     bark () {
         console.log('bark')
     }

     run () {
         console.log('run')
     }

     handleOnClick () {
         this.bark();
         this.run();
     }

     render () {
         return (<div onClick={this.handleOnClick.bind(this)}>DOG</div>)
     }
 }
 #+END_SRC

 如果不使用 =bind(this)=, 出现如下错误:
 [[file:screenshotImg/FireShot%20Capture%20041%20-%20Hello,%20world!%20-%20http___localhost_3000_.png]]
